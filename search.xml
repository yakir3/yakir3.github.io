<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/3eeb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><h3 id="For-test"><a href="#For-test" class="headerlink" title="For test."></a>For test.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /bin/bash</span><br><span class="line">echo test</span><br></pre></td></tr></table></figure>

<p>To Google <a href="https://www.google.com/">谷歌</a></p>
]]></content>
  </entry>
  <entry>
    <title>Docker学习记录</title>
    <url>/posts/c06e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、Docker-基本原理"><a href="#一、Docker-基本原理" class="headerlink" title="一、Docker 基本原理"></a>一、Docker 基本原理</h3><h4 id="1-docker-基本概念"><a href="#1-docker-基本概念" class="headerlink" title="1.docker 基本概念"></a>1.docker 基本概念</h4><p>Docker Client： 客户端<br>Docker Daemon：服务端<br>Docker Images：镜像（只读 CD）<br>Docker Registry： 镜像仓库<br>Docker Container：实际运行服务的容器，通过 Images 启动（可以认为 Container 提供硬件环境，使用 Images 提供好的系统盘，加上项目代码，即可运行服务）</p>
<span id="more"></span>
<img data-src="/posts/c06e/docker1.png" class>
<img data-src="/posts/c06e/docker2.png" class>
<img data-src="/posts/c06e/docker3.png" class>

<p>为什么使用Docker</p>
<ul>
<li>应用整体交付：一致的运行环境，DevOps。</li>
<li>资源利用率高。</li>
<li>更快的启动时间：应用扩容。</li>
</ul>
<h4 id="2-Dockerfile-编写规范"><a href="#2-Dockerfile-编写规范" class="headerlink" title="2.Dockerfile 编写规范"></a>2.Dockerfile 编写规范</h4><ol>
<li>使用统一的 base 镜像。</li>
<li>动静分离（基础稳定内容放在底层）。</li>
<li>最小原则（镜像只打包必需的东西）。</li>
<li>一个原则（每个镜像只有一个功能，交互通过网络，模块化管理）。</li>
<li>使用更少的层，减少每层的内容。</li>
<li>不要在 Dockerfile 单独修改文件权限（entrypoint &#x2F; 拷贝+修改权限同时操作）。</li>
<li>利用 cache 加快构建速度。</li>
<li>版本控制和自动构建（放入 git 版本控制中，自动构建镜像，构建参数&#x2F;变量给予文档说明）。</li>
<li>使用 .dockerignore 文件（排除文件和目录）</li>
</ol>
<p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile 指令介绍</a></p>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ACK 集群日志接入 SLS</title>
    <url>/posts/4a2a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、接入前提"><a href="#一、接入前提" class="headerlink" title="一、接入前提"></a>一、接入前提</h2><p><strong>ACK 集群开启日志服务组件Logtail</strong></p>
<ul>
<li>创建集群时启用Logtail（初始化ACK 集群时操作，新集群建议开启）<img data-src="/posts/4a2a/acksls1.png" class></li>
</ul>
<span id="more"></span>
<ul>
<li><p>为已有集群启用Logtail：在ACK控制台–&gt; 进入对应集群管理界面 –&gt; 运维管理 –&gt; 组件管理，找到logtail-ds 组件并点击安装即可。</p>
<img data-src="/posts/4a2a/acksls2.png" class>
</li>
<li><p>创建成功后即可在SLS 控制台搜索到相关集群Project</p>
</li>
</ul>
<img data-src="/posts/4a2a/acksls3.png" class>


<h2 id="二、接入日志方式"><a href="#二、接入日志方式" class="headerlink" title="二、接入日志方式"></a>二、接入日志方式</h2><h3 id="2-1-ACK-集群手动接入"><a href="#2-1-ACK-集群手动接入" class="headerlink" title="2.1 ACK 集群手动接入"></a>2.1 ACK 集群手动接入</h3><blockquote>
<p>本次接入应用标准输出日志，如需接入文件日志，还需创建对应volumeMounts和volumes 配置，规则逻辑类似。</p>
</blockquote>
<h4 id="1）通过控制台配置"><a href="#1）通过控制台配置" class="headerlink" title="1）通过控制台配置"></a>1）通过控制台配置</h4><ul>
<li>进入应用详情页</li>
</ul>
<img data-src="/posts/4a2a/acksls4.png" class>

<ul>
<li>点击应用编辑按钮，添加相关日志采集配置。</li>
</ul>
<img data-src="/posts/4a2a/acksls5.png" class>
<img data-src="/posts/4a2a/acksls6.png" class>

<h4 id="2）通过YAML-模板创建（Deployment-x2F-Pod）"><a href="#2）通过YAML-模板创建（Deployment-x2F-Pod）" class="headerlink" title="2）通过YAML 模板创建（Deployment &#x2F; Pod）"></a>2）通过YAML 模板创建（Deployment &#x2F; Pod）</h4><ul>
<li><p>采集规则</p>
<blockquote>
<ul>
<li>name: aliyun_logs_{Logstore名称}<br> value: {日志采集路径}</li>
</ul>
</blockquote>
</li>
<li><p>模板关键配置示例</p>
</li>
</ul>
<p>Pod 示例部分：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-demo-app</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="comment">######### 配置 环境变量 ###########</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_log-stdout</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">stdout</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_log-varlog</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">/var/log/*.log</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_mytag1_tags</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">tag1=v1</span></span><br><span class="line">    <span class="comment">###############################</span></span><br><span class="line">    <span class="comment">######### 配置volume mount ###########</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volumn-sls-mydemo</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volumn-sls-mydemo</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">  <span class="comment">###############################</span></span><br></pre></td></tr></table></figure>
<p>deployment 示例部分：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">args:</span> <span class="string">xxx-args</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_app-110760134-domain-event-center</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">stdout</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">xxx-image</span></span><br></pre></td></tr></table></figure>
<p>多个应用收集到同一个logstore 示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#应用A 配置：</span></span><br><span class="line"><span class="comment">######### 配置 环境变量 ###########</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_app1-stdout</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">stdout</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_app1-stdout_logstore</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">stdout-logstore</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">#应用B 配置：</span></span><br><span class="line"><span class="comment">######### 配置 环境变量 ###########</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_app2-stdout</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">stdout</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aliyun_logs_app2-stdout_logstore</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">stdout-logstore</span></span><br></pre></td></tr></table></figure>

<h4 id="3）验证查看日志"><a href="#3）验证查看日志" class="headerlink" title="3）验证查看日志"></a>3）验证查看日志</h4><ul>
<li>登录SLS 控制台，进入对应集群Project</li>
</ul>
<img data-src="/posts/4a2a/acksls7.png" class>

<ul>
<li>查询分析</li>
</ul>
<img data-src="/posts/4a2a/acksls8.png" class>

<h4 id="4）其他"><a href="#4）其他" class="headerlink" title="4）其他"></a>4）其他</h4><ul>
<li>注意事项<blockquote>
<p><strong>注意：</strong><br>**    当多个不同namespace 的同名应用配置为同一个logstore 时，可通过__tag__ 过滤条件，搜索对应需要的日志。**<br>**    如需自定义tag 区分不同日志时，可通过自定义tag 区分。**</p>
<img data-src="/posts/4a2a/acksls9.png" class></blockquote>
</li>
</ul>
<blockquote>
<p>参考阿里云官方文档：<a href="https://help.aliyun.com/document_detail/87540.html">https://help.aliyun.com/document_detail&#x2F;87540.html</a></p>
</blockquote>
<h3 id="2-2-DaemonSet-方式接入"><a href="#2-2-DaemonSet-方式接入" class="headerlink" title="2.2 DaemonSet 方式接入"></a>2.2 DaemonSet 方式接入</h3><h4 id="1）通过DaemonSet-控制台方式采集"><a href="#1）通过DaemonSet-控制台方式采集" class="headerlink" title="1）通过DaemonSet 控制台方式采集"></a>1）通过DaemonSet 控制台方式采集</h4><blockquote>
<p>可选择采集文件或标准输出，本次接入应用标准输出日志。</p>
</blockquote>
<ul>
<li>在SLS 控制台搜索 <strong>Kubenetes - 标准输出</strong>，选择日志收集方式。</li>
</ul>
<img data-src="/posts/4a2a/acksls10.png" class>

<ul>
<li>选择&#x2F;创建 Project 和store。</li>
</ul>
<img data-src="/posts/4a2a/acksls11.png" class>

<ul>
<li>选择已有机器组</li>
</ul>
<img data-src="/posts/4a2a/acksls12.png" class>

<ul>
<li>收集过滤需要的日志，详细语法可参考文档。</li>
</ul>
<img data-src="/posts/4a2a/acksls13.png" class>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;IncludeLabel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ExcludeLabel&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;io.kubernetes.container.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;camel-k-operator&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;IncludeEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;CAMEL_K_INTEGRATION&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;service_docker_stdout&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进入SLS 控制台，并选择对应Project。点击创建索引</li>
</ul>
<img data-src="/posts/4a2a/acksls14.png" class>
<img data-src="/posts/4a2a/acksls15.png" class>

<ul>
<li>索引创建后等待1 min左右，即可看到标准输出日志。</li>
</ul>
<img data-src="/posts/4a2a/acksls16.png" class>

<h4 id="2）通过DaemonSet-CRD-方式采集"><a href="#2）通过DaemonSet-CRD-方式采集" class="headerlink" title="2）通过DaemonSet CRD 方式采集"></a>2）通过DaemonSet CRD 方式采集</h4><blockquote>
<p>Edas 中配置日志收集即使用的该方式。</p>
</blockquote>
<p><a href="https://help.aliyun.com/document_detail/74878.htm">https://help.aliyun.com/document_detail&#x2F;74878.htm</a></p>
<h3 id="2-3-Sidecar-方式接入"><a href="#2-3-Sidecar-方式接入" class="headerlink" title="2.3 Sidecar 方式接入"></a>2.3 Sidecar 方式接入</h3><h4 id="1）通过Sidecar-控制台方式采集"><a href="#1）通过Sidecar-控制台方式采集" class="headerlink" title="1）通过Sidecar 控制台方式采集"></a>1）通过Sidecar 控制台方式采集</h4><p><a href="https://help.aliyun.com/document_detail/100575.htm">https://help.aliyun.com/document_detail&#x2F;100575.htm</a></p>
<h4 id="2）通过Sidecar-CRD-方式采集"><a href="#2）通过Sidecar-CRD-方式采集" class="headerlink" title="2）通过Sidecar CRD 方式采集"></a>2）通过Sidecar CRD 方式采集</h4><p><a href="https://help.aliyun.com/document_detail/100575.htm">https://help.aliyun.com/document_detail&#x2F;100575.htm</a></p>
<blockquote>
<p>参考阿里云官方文档：<a href="https://help.aliyun.com/document_detail/66654.html">https://help.aliyun.com/document_detail&#x2F;66654.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>流量网关方案与灰度发布</title>
    <url>/posts/dc02.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="流量网关方案与灰度发布方式"><a href="#流量网关方案与灰度发布方式" class="headerlink" title="流量网关方案与灰度发布方式"></a>流量网关方案与灰度发布方式</h3><h4 id="一、阿里云原生-Ingress-方式"><a href="#一、阿里云原生-Ingress-方式" class="headerlink" title="一、阿里云原生 Ingress 方式"></a>一、阿里云原生 Ingress 方式</h4><p><strong>前置要求</strong></p>
<ol>
<li>集群已安装 Ingress 组件</li>
<li>明确灰度发布规则（使用 cookie 值匹配 A&#x2F;B 测试规则）</li>
</ol>
<p><strong>操作步骤</strong></p>
<ol>
<li>部署新旧版本 Deployment 和 Service</li>
</ol>
<p>通过 Edas 创建新应用，并暴露 service（无需 SLB 暴露）。已 app1 应用为例：</p>
<table>
<thead>
<tr>
<th><strong>资源</strong></th>
<th><strong>旧版本</strong></th>
<th><strong>新版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Edas 应用</td>
<td>app1-test</td>
<td>app1-new-test</td>
</tr>
<tr>
<td>Deployment</td>
<td>app1-test-group-x-xxx</td>
<td>app1-new-test-group-x-xxx</td>
</tr>
<tr>
<td>Service</td>
<td>app1-svc</td>
<td>app1-new-svc</td>
</tr>
</tbody></table>
<span id="more"></span>

<ol start="2">
<li><p>配置 ingress</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    # 匹配规则：正则匹配 cookie 值</span><br><span class="line">    nginx.ingress.kubernetes.io/service-match: |</span><br><span class="line">      new-nginx: cookie(&quot;foo&quot;, /^aBc123.*/)</span><br><span class="line">  name: gray-release</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: www.yakir.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      # 旧版本服务</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: old-nginx</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">        path: /</span><br><span class="line">        pathType: ImplementationSpecific</span><br><span class="line">      # 新版本服务</span><br><span class="line">      - backend:</span><br><span class="line">          service:</span><br><span class="line">            name: new-nginx</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">        path: /</span><br><span class="line">        pathType: ImplementationSpecific</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证请求<br>略</p>
</li>
</ol>
<h4 id="二、Istio-网关方式"><a href="#二、Istio-网关方式" class="headerlink" title="二、Istio 网关方式"></a>二、Istio 网关方式</h4><p><strong>前置要求</strong></p>
<ol>
<li><p>集群部署 istio </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载 istio</span><br><span class="line">curl -L https://istio.io/downloadIstio | sh -</span><br><span class="line"></span><br><span class="line"># 进入 istio 目录，执行安装命令</span><br><span class="line">cd istio-1.13.3/</span><br><span class="line">./bin/istioctl install --set profile=demo</span><br><span class="line"></span><br><span class="line"># 查看可安装的环境（default 用于生产环境，demo 用于测试）</span><br><span class="line">./bin/istioctl profile list</span><br><span class="line">Istio configuration profiles:</span><br><span class="line">    default</span><br><span class="line">    demo</span><br><span class="line">    empty</span><br><span class="line">    external</span><br><span class="line">    minimal</span><br><span class="line">    openshift</span><br><span class="line">    preview</span><br><span class="line">    remote</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>明确灰度发布规则（使用 cookie 值匹配 A&#x2F;B 测试规则）</p>
</li>
</ol>
<p><strong>操作步骤</strong></p>
<ol>
<li><p>部署新旧版本 Deployment 和 Service</p>
</li>
<li><p>配置 istio 网关与匹配规则</p>
</li>
</ol>
<p>istio-gateway.yaml 文件内容，执行 kubectl apply -f istio-gateway.yaml &amp;&amp; kubectl apply -f virtualservice.yaml 创建相关资源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: istio-gateway-test</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: ingressgateway # use istio default controller</span><br><span class="line">  servers:</span><br><span class="line">  - port:</span><br><span class="line">      number: 80</span><br><span class="line">      name: http</span><br><span class="line">      protocol: HTTP</span><br><span class="line">    tls:</span><br><span class="line">      httpsRedirect: true</span><br><span class="line">    hosts:</span><br><span class="line">    - &quot;*.yakir.com&quot;</span><br><span class="line">  - port:</span><br><span class="line">      number: 443</span><br><span class="line">      name: https</span><br><span class="line">      protocol: HTTPS</span><br><span class="line">    tls:</span><br><span class="line">      mode: SIMPLE</span><br><span class="line">      credentialName: yakir-com.cert</span><br><span class="line">    hosts:</span><br><span class="line">    - &quot;*.yakir.com&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: virtual-service-test</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - yakir.yakir.com</span><br><span class="line">  gateways:</span><br><span class="line">  - istio-gateway-test</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - headers:</span><br><span class="line">        cookie:</span><br><span class="line">          regex: &quot;^(.*?;)?(foo=aBc123.*)(;.*)?$&quot;</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: new-nginx-svc</span><br><span class="line">        port:</span><br><span class="line">          number: 80</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: old-nginx-svc</span><br><span class="line">        port:</span><br><span class="line">          number: 80</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证请求<br>略</li>
</ol>
<blockquote>
<p>istio 配置 https 证书：</p>
<ol>
<li>导入 yakir.com 证书（可通过控制台或 kubectl cli 方式导入）<br>控制台方式：配置管理 -&gt; 保密字典 中点击创建，填入 crt、key、名称，选择 TLS 证书类型，点击确定导入证书密钥。</li>
<li>istio gateway 资源开启 https 配置，选择 secret 方式导入 （见上述配置文件）</li>
</ol>
</blockquote>
<h4 id="应用调整为灰度发布策略操作方式"><a href="#应用调整为灰度发布策略操作方式" class="headerlink" title="应用调整为灰度发布策略操作方式"></a>应用调整为灰度发布策略操作方式</h4><p>第一种方式：保留两套应用实现</p>
<ul>
<li><p>新建 CI&#x2F;CD 流水线 + Edas 应用 + Service，即同时保留两套应用（如日常环境 app1-test、app1-test-new）</p>
</li>
<li><p>在网关入口处，将 app1 域名流量按照规则匹配到两个应用 Service（默认规则流量进入稳定版应用对应的 Service，匹配到 cookie 值规则的流量进入新版本应用对应的 Service）</p>
</li>
<li><p>应用 owner 操作：将应用域名解析修改到 WAF 解析（回源为实际 ingress 或 istio 网关地址）</p>
</li>
</ul>
<p><del>第二种方式：复用一套应用，通过分批发布方式？（暂无法实现）</del></p>
<ul>
<li>通过分批发布可以保留两个新旧版本 Deployment ，使用同一个Service。通过 DestinationRule 规则匹配不同流量流入不同 Deployment，实现灰度流量分流。</li>
</ul>
<p>问题点：每次需要手动获取发布的新旧版本 Deployment 的 label 值，更新 DestinationRule 规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: virtual-service-test</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - yakir.yakir.com</span><br><span class="line">  gateways:</span><br><span class="line">  - istio-gateway-test</span><br><span class="line">  http:</span><br><span class="line">  # 路由规则目标使用同一个 host，通过 subsets 子集来区分流量走向</span><br><span class="line">  - match:</span><br><span class="line">    - headers:</span><br><span class="line">        cookie:</span><br><span class="line">          regex: &quot;^(.*?;)?(foo=aBc123.*)(;.*)?$&quot;</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: test-nginx-svc</span><br><span class="line">        subset: new</span><br><span class="line">        port:</span><br><span class="line">          number: 80</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: test-nginx-svc</span><br><span class="line">        subset: old</span><br><span class="line">        port:</span><br><span class="line">          number: 80</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind: DestinationRule</span><br><span class="line">metadata:</span><br><span class="line">  name: destination-rule-test</span><br><span class="line">spec:</span><br><span class="line">  host: test-nginx-svc</span><br><span class="line">  # 使用 label 值来区别流量流入的 Deployment</span><br><span class="line">  subsets:</span><br><span class="line">  - name: old</span><br><span class="line">    labels:</span><br><span class="line">      edas.oam.acversion: &quot;3&quot;</span><br><span class="line">  - name: new</span><br><span class="line">    labels:</span><br><span class="line">      edas.oam.acversion: &quot;4&quot;</span><br></pre></td></tr></table></figure>


<h4 id="其他"><a href="#其他" class="headerlink" title="***其他"></a>***其他</h4><p><strong>注意事项</strong><br>可观测性：新增 CRD 资源，开启 ingress 日志。<br>istio 高可用性保证？<br>兜底方案： SLB 兜底？</p>
<p><strong>参考文档</strong><br>阿里云 Ingress：<a href="https://help.aliyun.com/document_detail/200941.html#section-t2t-eik-oyr">https://help.aliyun.com/document_detail&#x2F;200941.html#section-t2t-eik-oyr</a><br>Istio 官网：<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/">https://istio.io/latest/zh/docs/concepts/traffic-management/</a></p>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>Istio</tag>
      </tags>
  </entry>
  <entry>
    <title>git flow 工作流理解</title>
    <url>/posts/539.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、gitflow：版本分支管理策略（相当于对git的包装）"><a href="#一、gitflow：版本分支管理策略（相当于对git的包装）" class="headerlink" title="一、gitflow：版本分支管理策略（相当于对git的包装）"></a>一、gitflow：版本分支管理策略（相当于对git的包装）</h3><ol>
<li>GitFlow描述</li>
</ol>
<ul>
<li>常用分支包括master、develop、feature、release、hotfix（support分支不常用）</li>
<li>其中master、develop是远程分支，feature、release、hotfix是本地分支。<ul>
<li>远程分支是指需要push到gitlab、github远程仓库中</li>
<li>本地分支指开发人员的本地开发时使用的git版本控制环境</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ol start="2">
<li>GitFlow流程图及描述理解</li>
</ol>
<img data-src="/posts/539/gf1.png" class>
<img data-src="/posts/539/gf2.png" class>

<ul>
<li>master：主干分支</li>
</ul>
<img data-src="/posts/539/gf3.png" class>

<ul>
<li><p>最稳定分支、功能完整、可随时发布线上环境（只读分支，只能从hotfix&#x2F;release合并 不能修改）</p>
</li>
<li><p>在master分支上的推送应该打tag记录追溯；</p>
</li>
<li><p>develop：开发分支 ß</p>
<ul>
<li>功能最新最全的分支，基于master分支克隆（仅首次克隆）；</li>
<li>feature分支本地自测通过后合并到develop分支然后删除；</li>
<li>收集所有上线功能后（包含所有发布到下一个release的代码）从delevop拉去release分支进行提测；</li>
<li>release&#x2F;hotfix分支上线完毕，合并到develop并推送；</li>
</ul>
</li>
<li><p>feature：功能开发分支</p>
</li>
</ul>
<img data-src="/posts/539/gf4.png" class>

<ul>
<li><p>开发某部分新功能，基于develop分支克隆，功能开发完毕且本地自测通过（编译完成且无异常）合并到develop分支；</p>
</li>
<li><p>可存在多个feature分支，即团队多人同时开发创建多个临时分支，功能完成后可选删除；</p>
</li>
<li><p>release：测试分支</p>
</li>
</ul>
<img data-src="/posts/539/gf5.png" class>

<ul>
<li><p>用于提交给测试人员进行功能测试，基于feature分支合并到develop之后，从develop分支克隆；</p>
</li>
<li><p>测试过程发现BUG在本分支进行修复，修复时创建修复分支bugfix-*，修复完所有bug上线后一次性合并到develop&#x2F;master分支并推送（完成功能），推送master分支时打tag；</p>
</li>
<li><p>临时分支，功能上线后可选删除（开启release测试后，不允许develop分支新功能继续合并到release分支，新功能需放到下一个release测试及发布）；</p>
</li>
<li><p>hotfix：补丁分支</p>
</li>
</ul>
<img data-src="/posts/539/gf6.png" class>

<ul>
<li>基于master分支克隆，主要用于线上版本进行BUG修复；</li>
<li>修复bug后合并到develop&#x2F;master分支并推送（所有hotfix分支的修改会进入到下一个release），推送master分支时打tag；</li>
<li>临时分支，修复bug后可选删除</li>
</ul>
<ol start="3">
<li>开发准则与约定</li>
</ol>
<ul>
<li>准则<ul>
<li>除了源码相关的东西之外，其他build产生的东西（如：maven的target文件夹，.idea文件夹等），均不能提交进入源码仓库，添加到.gitignore文件中忽略掉</li>
<li>开发人员要严格按照我们约定的gitflow版本分支管理流程切换到指定分支，开发相应的功能</li>
<li>任务完成后需要根据测试用例经过严格的自测才能推送develop，严禁将编译不通过，提交不完全的代码推送到远程分支</li>
</ul>
</li>
<li>约定：<ul>
<li>主分支名称：master    主开发分支：develop</li>
<li>标签（tag）名称：v*. release，其中“*” 为版本号，“release” 小写，如：v1.0.0. release</li>
<li>新功能开发分支名称：feature-<em>，其中“</em>” 为对应jira（Aone）上的任务编号</li>
<li>发布分支名称：release-<em>，其中“</em>” 为版本号，“release”小写，如：release-1.0.0，release分支上修复bug的分支名称为bugfix-*</li>
<li>master的bug修复分支名称：hotfix-<em>，其中“</em>” 为对应jira（Aone）上的任务编号</li>
</ul>
</li>
</ul>
<h3 id="二、测试部分"><a href="#二、测试部分" class="headerlink" title="二、测试部分"></a>二、测试部分</h3><ul>
<li>本地git flow init 初始化仓库，提交develop分支</li>
</ul>
<img data-src="/posts/539/gf7.png" class>
<img data-src="/posts/539/gf8.png" class>

<ul>
<li>提交到远程测试用github仓库（使用ssh公钥认证方式），可以看到develop分支已有第一次提交</li>
</ul>
<img data-src="/posts/539/gf9.png" class>

<ul>
<li>到tmp目录下新建工作目录，并clone下远程仓库到本地（模拟本地开发）</li>
</ul>
<img data-src="/posts/539/gf10.png" class>

<ul>
<li>初始化仓库后，拉取develop分支到本地进行开发。此时可以切出feature分支进行功能开发</li>
</ul>
<img data-src="/posts/539/gf11.png" class>
<img data-src="/posts/539/gf12.png" class>

<ul>
<li>开发功能提交后进行提交到远程仓库并track远程分支。后续可以git push持续提交</li>
</ul>
<img data-src="/posts/539/gf13.png" class>
<img data-src="/posts/539/gf14.png" class>

<ul>
<li>功能开发完成后，将分支合并到develop分支并删除本地feature分支（加上-F参数可以同时删除远程分支）</li>
</ul>
<img data-src="/posts/539/gf15.png" class>
<p>finish提交后即将新功能合并到develop分支，完成新功能开发。后续即执行release发布操作，步骤类似</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>helm 部署应用</title>
    <url>/posts/ce0f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、Helm-安装与模板"><a href="#一、Helm-安装与模板" class="headerlink" title="一、Helm 安装与模板"></a>一、Helm 安装与模板</h3><h4 id="1）Helm-安装部署"><a href="#1）Helm-安装部署" class="headerlink" title="1）Helm 安装部署"></a>1）Helm 安装部署</h4><ul>
<li><a href="https://helm.sh/zh/docs/intro/install/">安装二进制命令</a>（本地需要连接上kubernetes 集群）</li>
</ul>
<span id="more"></span>
<ul>
<li>安装阿里云helm 插件与操作<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Helm 插件</span></span><br><span class="line">helm plugin install https://github.com/AliyunContainerService/helm-acr</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="comment"># 配置本地仓库映射</span></span><br><span class="line"><span class="built_in">export</span> HELM_REPO_USERNAME=<span class="string">&#x27;&lt;企业版实例访问凭证中账号&gt;&#x27;</span></span><br><span class="line"><span class="built_in">export</span> HELM_REPO_PASSWORD=<span class="string">&#x27;&lt;企业版实例访问凭证中密码&gt;&#x27;</span></span><br><span class="line">helm repo add &lt;本地仓库名称&gt; acr://registry-chart-test.cn-hangzhou.cr.aliyuncs.com/&lt;命名空间&gt;/&lt;Chart仓库名称&gt; --username <span class="variable">$&#123;HELM_REPO_USERNAME&#125;</span> --password <span class="variable">$&#123;HELM_REPO_PASSWORD&#125;</span></span><br><span class="line"><span class="comment">#export HELM_REPO_USERNAME=devops@ib_daily</span></span><br><span class="line"><span class="comment">#export HELM_REPO_PASSWORD=2RJPfCgHXroSYQga</span></span><br><span class="line"><span class="comment">#helm repo add aliyun-acr-repo acr://registry-chart-test.cn-hangzhou.cr.aliyuncs.com/chart-test/app-test --username $&#123;HELM_REPO_USERNAME&#125; --password $&#123;HELM_REPO_PASSWORD&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送Chart</span></span><br><span class="line"><span class="comment">#本地创建一个 Chart</span></span><br><span class="line">helm create &lt;Chart 名称&gt;</span><br><span class="line"><span class="comment">#helm create app-test</span></span><br><span class="line"><span class="comment">#推送 Chart 目录</span></span><br><span class="line">helm cm-push &lt;Chart 名称&gt; &lt;本地仓库名称&gt;</span><br><span class="line"><span class="comment">#helm cm-push app-test aliyun-acr-repo</span></span><br><span class="line"><span class="comment">#或者推送 Chart 压缩包</span></span><br><span class="line">helm cm-push &lt;Chart 名称&gt;-&lt;Chart 版本&gt;.tgz &lt;本地仓库名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取Chart</span></span><br><span class="line"><span class="comment">#从线上Chart 仓库更新本地Chart 索引</span></span><br><span class="line">helm repo update</span><br><span class="line"><span class="comment">#helm repo update aliyun-acr-repo</span></span><br><span class="line"><span class="comment">#拉取Chart</span></span><br><span class="line">helm fetch &lt;本地仓库名称&gt;/&lt;Chart 名称&gt; --version &lt;Chart 版本&gt;</span><br><span class="line"><span class="comment">#helm fetch aliyun-acr-repo/app-test --version=20211228100329-daily</span></span><br><span class="line"><span class="comment">#或者直接安装Chart</span></span><br><span class="line">helm install -f values.yaml &lt;本地仓库名称&gt;/&lt;Chart 名称&gt; --version &lt;Chart 版本&gt;</span><br><span class="line"><span class="comment">#helm install app-test aliyun-acr-repo/app-test --version 20211228100329-daily --namespace daily-apps</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>helm install 操作实际执行按顺序安装资源：</p>
<ul>
<li>Namespace</li>
<li>NetworkPolicy</li>
<li>ResourceQuota</li>
<li>LimitRange</li>
<li>PodSecurityPolicy</li>
<li>PodDisruptionBudget</li>
<li>ServiceAccount</li>
<li>Secret</li>
<li>SecretList</li>
<li>ConfigMap</li>
<li>StorageClass</li>
<li>PersistentVolume</li>
<li>PersistentVolumeClaim</li>
<li>CustomResourceDefinition</li>
<li>ClusterRole</li>
<li>ClusterRoleList</li>
<li>ClusterRoleBinding</li>
<li>ClusterRoleBindingList</li>
<li>Role</li>
<li>RoleList</li>
<li>RoleBinding</li>
<li>RoleBindingList</li>
<li>Service</li>
<li>DaemonSet</li>
<li>Pod</li>
<li>ReplicationController</li>
<li>ReplicaSet</li>
<li>Deployment</li>
<li>HorizontalPodAutoscaler</li>
<li>StatefulSet</li>
<li>Job</li>
<li>CronJob</li>
<li>Ingress</li>
<li>APIService</li>
</ul>
</blockquote>
</li>
</ul>
<p><a href="https://helm.sh/zh/docs/helm/helm/">常用参数</a></p>
<blockquote>
<ul>
<li>查看本地仓库：helm repo list</li>
<li>添加&#x2F;删除仓库：helm repo add xxx &#x2F; helm repo remove xxx</li>
<li>推送&#x2F;拉取charts：helm cm-push xxx &#x2F; helm fetch&#x2F;pull xxx</li>
<li>安装&#x2F;卸载charts：helm install xxx &#x2F;  helm uninstall xxx</li>
<li>升级&#x2F;回滚：helm upgrade xxx &#x2F; helm rollback xxx <revision></revision></li>
<li>创建本地自己的charts： helm create xxx</li>
<li>查看charts 可自定义配置项&#x2F;获取自定义配置项 ：helm show values &#x2F; helm get values</li>
</ul>
</blockquote>
<ul>
<li>配置跨账号ACR 拉取镜像<blockquote>
<p>helm 部署时需要pull image 部署，因此需要配置跨账号ACR 拉取镜像。参考：<a href="https://yuque.antfin.com/kifo8h/nee5aa/wgui7o">跨账号ACR 拉取镜像配置</a></p>
</blockquote>
</li>
</ul>
<h4 id="2）Helm-模板与语法编写"><a href="#2）Helm-模板与语法编写" class="headerlink" title="2）Helm 模板与语法编写"></a>2）Helm 模板与语法编写</h4><blockquote>
<p>详情参考：<a href="https://www.qikqiak.com/k8strain/helm/demo/">Charts 文件格式，模板编写</a></p>
</blockquote>
<ul>
<li><p>内置对象</p>
</li>
<li><p>基本目录结构内容：Chart.yaml（chart 信息说明） 、Values.yaml（自定义变量） 、charts（子chart目录，依赖）</p>
</li>
<li><p>templates 模板（实际安装到K8S 集群中的资源定义Yaml 模板文件，如deployment、pod 等）</p>
<ul>
<li>资源模板：confimap.yaml、deployment.yaml 等</li>
<li>命名模板：_helpers.tpl</li>
</ul>
</li>
<li><p>函数和流水线：<a href="https://helm.sh/zh/docs/chart_template_guide/function_list/">函数列表</a>，<a href="https://helm.sh/zh/docs/chart_template_guide/control_structures/">流程控制</a></p>
</li>
<li><p>访问文件</p>
</li>
</ul>
<h3 id="二、测试验证部署app-test"><a href="#二、测试验证部署app-test" class="headerlink" title="二、测试验证部署app-test"></a>二、测试验证部署app-test</h3><h4 id="1）本地安装helm、kubectl（连接K8S-集群）二进制命令"><a href="#1）本地安装helm、kubectl（连接K8S-集群）二进制命令" class="headerlink" title="1）本地安装helm、kubectl（连接K8S 集群）二进制命令"></a>1）本地安装helm、kubectl（连接K8S 集群）二进制命令</h4><h4 id="2）初始化配置app-test"><a href="#2）初始化配置app-test" class="headerlink" title="2）初始化配置app-test"></a>2）初始化配置app-test</h4><ul>
<li><p>初始化应用目录：helm create app-test</p>
</li>
<li><p>应用app-test 目录结构</p>
</li>
</ul>
<img data-src="/posts/ce0f/helm1.png" class>

<ul>
<li>关键配置信息<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Chart.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">app-test</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">application</span> <span class="string">app-test</span> <span class="string">for</span> <span class="string">env</span> <span class="string">daily</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">20211215123042</span><span class="string">-daily</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="string">20211215123042_daily</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line"><span class="attr">replicaCount:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">registry-chart-test.cn-hangzhou.cr.aliyuncs.com/ib-ibos/app-test</span></span><br><span class="line">  <span class="attr">pullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">imagePullSecrets:</span> []</span><br><span class="line"><span class="attr">nameOverride:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">fullnameOverride:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">serviceAccount:</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">annotations:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">podAnnotations:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">podSecurityContext:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">annotations:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">reos.com.cn</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">          <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line">  <span class="attr">tls:</span> []</span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">autoscaling:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nodeSelector:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">tolerations:</span> []</span><br><span class="line"></span><br><span class="line"><span class="attr">affinity:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3）配置镜像仓库，部署应用"><a href="#3）配置镜像仓库，部署应用" class="headerlink" title="3）配置镜像仓库，部署应用"></a>3）配置镜像仓库，部署应用</h4><ul>
<li>配置远程ACR 企业版仓库，参考 <a href="#ht9xj">Helm安装部署</a> 部分。</li>
</ul>
<img data-src="/posts/ce0f/helm2.png" class>

<ul>
<li>部署应用<ul>
<li><p>执行部署命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install app-test aliyun-acr-repo/app-test --version 20211228100329-daily --namespace daily-apps</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署结果</p>
</li>
</ul>
</li>
</ul>
<img data-src="/posts/ce0f/helm3.png" class>
<img data-src="/posts/ce0f/helm4.png" class>

<ul>
<li>更新版本<img data-src="/posts/ce0f/helm5.png" class></li>
</ul>
<h3 id="三、问题点"><a href="#三、问题点" class="headerlink" title="三、问题点"></a>三、问题点</h3><ul>
<li><p>使用helm 命令安装需本地连接K8S 集群（需提供API Server 公网EIP）</p>
</li>
<li><p>与阿里云Edas 产品兼容问题</p>
<ul>
<li>使用helm 部署的应用与Edas 不共通，因此使用helm 部署的无法从Edas 上查看应用的相关信息</li>
<li>Edas 支持将手动部署的Deployment 手动导入，参考：<a href="https://help.aliyun.com/document_detail/202036.html">https://help.aliyun.com/document_detail&#x2F;202036.html</a>（自行部署导入Edas 的应用暂未确定是否能完整导入Edas 组件注入的变量）</li>
</ul>
</li>
<li><p>版本控制与镜像拉取</p>
<ul>
<li>helm 通过配置values 变量值写入或更新 image-&gt;repository 的值进行pull 镜像更新，并通过 helm push 推送pull 的镜像配置到私有仓库中。</li>
<li>helm 通过upgrade 与rollback 命令进行已部署应用的升级与回滚功能。</li>
</ul>
</li>
<li><p>与原有CI&#x2F;CD 配置使用问题</p>
<ul>
<li>helm 部署只能通过本地更新配置并执行，无法与现有的 CI&#x2F;CD 流水线进行配合使用，需要进行调整。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S-RBAC权限控制</title>
    <url>/posts/fa45.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、RBAC简易概述"><a href="#一、RBAC简易概述" class="headerlink" title="一、RBAC简易概述"></a>一、RBAC简易概述</h3><img data-src="/posts/fa45/gaisu.png" class>
<h4 id="1-RBAC-四种-API-对象"><a href="#1-RBAC-四种-API-对象" class="headerlink" title="1) RBAC 四种 API 对象"></a>1) RBAC 四种 API 对象</h4><ul>
<li>Role：一组权限的集合，在一个命名空间中，可以用其来定义一个角色，只能对命名空间内的资源进行授权。如果是集群级别的资源，则需要使用ClusterRole。例如：定义一个角色用来读取Pod的权限</li>
<li>ClusterRole：具有和角色一致的命名空间资源的管理能力，还可用于以下特殊元素的授权<ul>
<li>集群范围的资源，例如Node</li>
<li>非资源型的路径，例如：&#x2F;healthz</li>
<li>包含全部命名空间的资源，例如Pods<blockquote>
<p>例如：定义一个集群角色可让用户访问任意secrets</p>
</blockquote>
</li>
</ul>
</li>
<li>RoleBinding：角色绑定</li>
<li>ClusterRoleBinding：集群角色绑定<blockquote>
<p>角色绑定和集群角色绑定用于把一个角色绑定在一个目标上，可以是User，Group，Service Account，使用RoleBinding为某个命名空间授权，使用ClusterRoleBinding为集群范围内授权。</p>
</blockquote>
</li>
</ul>
<p><strong>Role和ClusterRole是权限规则的定义</strong></p>
<ul>
<li>rules代表具体的授权规则，类似于阿里云RAM中的权限策略Policy</li>
<li>Role和ClusterRole区别只在于一个是集群级别的资源控制</li>
</ul>
<span id="more"></span>

<p><strong>RoleBinding和ClusterRoleBinding是将User、Group、ServiceAccount绑定到Role或ClusterRole中（类似阿里云RAM中将Policy赋权给RAM角色或RAM账号）</strong></p>
<ul>
<li>User、Group、ServiceAccount 是 K8S 集群中单独的概念，与系统级别不同。参考：<a href="https://www.qikqiak.com/k8strain2/security/rbac/#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2">https://www.qikqiak.com/k8strain2/security/rbac/#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2</a></li>
<li>RoleBinding 可以引用同一个 namespace 中的任何 Role ；或者一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到 RoleBinding 所在的 namespace。</li>
<li>如需 ClusterRole 绑定到集群中所有 namespace，必须要使用 ClusterRoleBinding</li>
<li>RoleBinding 对应可引用一个 ClusterRole 对象用于在 RoleBinding 所在的 namespace 内授予用户对所引用的 ClusterRole 中定义的 namespace 资源的访问权限。（在整个集群内定义一组通用角色，然后在不同 namespace 中复用这些角色）</li>
</ul>
<h4 id="2-资源引用方式"><a href="#2-资源引用方式" class="headerlink" title="2) 资源引用方式"></a>2) 资源引用方式</h4><ul>
<li>多数资源可以用其名称的字符串表示，也就是Endpoint中的URL相对路径，例如pod中的日志是GET &#x2F;api&#x2F;v1&#x2F;namaspaces&#x2F;{namespace}&#x2F;pods&#x2F;{podname}&#x2F;log</li>
<li>如果需要在一个RBAC对象中体现上下级资源，就需要使用“&#x2F;”分割资源和下级资源。</li>
</ul>
<p>例如：若想授权让某个主体同时能够读取Pod和Pod log，则可以配置 resources为一个数组</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">   <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>,<span class="string">&quot;pods/log&quot;</span>]</span><br><span class="line">   <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>通过名称（ResourceName）进行引用，在指定ResourceName后，使用get、delete、update、patch请求，就会被限制在这个资源实例范围内</li>
</ul>
<p>例如，下面的声明让一个主体只能对名为my-configmap的ConFigmap进行get和update操作：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">   <span class="attr">resources:</span> [<span class="string">&quot;configmap&quot;</span>]</span><br><span class="line">   <span class="attr">resourceNames:</span> [<span class="string">&quot;my-configmap&quot;</span>]</span><br><span class="line">   <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;update&quot;</span>]</span><br></pre></td></tr></table></figure>


<h4 id="3-rules-参数说明"><a href="#3-rules-参数说明" class="headerlink" title="3) rules 参数说明"></a>3) rules 参数说明</h4><ul>
<li>apiGroups：支持的API组列表，例如：”apiVersion: batch&#x2F;v1”等</li>
<li>resources：支持的资源对象列表，例如pods、deplayments、jobs等</li>
<li>resourceNames: 指定resource的名称（可选）</li>
<li>verbs：对资源对象的操作方法列表<blockquote>
<p>api-resources：所有资源信息<br>apiGroups：api-resources下的分类分组</p>
<p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#-strong-api-groups-strong-">查看API GROUP分组信息</a></p>
<ul>
<li>方式一：kubectl explain xxx ， xxx为 “kubectl api-resources” 输出结果的 NAME 值（输出结果的 VERSION 值为v1 则为默认的Core API 分组，默认以”” 表示，如 pods、services）</li>
<li>方式二：kubectl get –raw &#x2F;apis&#x2F;apps&#x2F;v1</li>
</ul>
</blockquote>
</li>
</ul>
<p>可通过 kubectl get –raw &#x2F;apis&#x2F;rbac.authorization.k8s.io&#x2F;v1 可以获取到 RBAC 四个 API 资源对象的相关信息，如下图：</p>
<img data-src="/posts/fa45/c31775e8bbe3.png" class>

<blockquote>
<p>创建资源&#x2F;信息的方式</p>
<ul>
<li>方式一：kubectl create -f xxx.yaml       –&gt;   文件方式创建</li>
<li>方式二：kubectl create –arg1&#x3D;xxx –arg2&#x3D;yyy     –&gt;  参数方式创建（后续可通过kubectl edit方式继续编辑）</li>
</ul>
</blockquote>
<h3 id="二、ServiceAccount-测试"><a href="#二、ServiceAccount-测试" class="headerlink" title="二、ServiceAccount 测试"></a>二、ServiceAccount 测试</h3><h4 id="1-创建-serviceaccount-账户并进行对应授权"><a href="#1-创建-serviceaccount-账户并进行对应授权" class="headerlink" title="1) 创建 serviceaccount 账户并进行对应授权"></a>1) 创建 serviceaccount 账户并进行对应授权</h4><ol>
<li><p>创建 serviceaccount 账户 camel-sva （只需defalut namespace）<br>执行命令：kubectl create serviceaccount camel-sva -n default</p>
<img data-src="/posts/fa45/634be995b5bc.png" class>
</li>
<li><p>创建 role 角色 （授权Integration、Kamelet、KameletBinding 3种资源的 curd 权限）<br>执行命令：kubectl create role camel-sva-role –verb&#x3D;* –resource&#x3D;integrations,kamelets,kameletbindings </p>
<img data-src="/posts/fa45/21812e1bbfad.png" class>
</li>
<li><p>绑定集群权限<br>命令：kubectl create rolebinding camel-sva-rolebinding –role&#x3D;camel-sva-role –serviceaccount&#x3D;default:camel-sva</p>
<img data-src="/posts/fa45/7528aa1bf3da.png" class>
</li>
<li><p>查看账号 secret 信息<br>命令：kubectl get secret&#x2F;camel-sva-token-mdt28 -oyaml</p>
<img data-src="/posts/fa45/de3ebdd4f016.png" class>
<p>将获取到的 token 值进行 base64 解码后即可用来调用 apiserver 接口，如下图（接口可通过 kubectl get –raw &#x2F;apis&#x2F; 进行获取）：</p>
<img data-src="/posts/fa45/1572c2ebc891.png" class></li>
</ol>
<h4 id="2-创建用户认证的-kubeconfig-文件"><a href="#2-创建用户认证的-kubeconfig-文件" class="headerlink" title="2) 创建用户认证的 kubeconfig 文件"></a>2) 创建用户认证的 kubeconfig 文件</h4><ol>
<li><p>创建集群配置文件<br>命令：kubectl config set-cluster kubernetes –certificate-authority&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt –server&#x3D;”<a href="https://10.0.0.142:6443&quot;">https://10.0.0.142:6443&quot;</a> –embed-certs&#x3D;true –kubeconfig&#x3D;.&#x2F;camel-sva.conf</p>
</li>
<li><p>生成 token（base64编码）<br>命令：D&#x3D;$(kubectl get secret camel-sva-token-mdt28 -o jsonpath&#x3D;{.data.token}|base64 -d)</p>
</li>
<li><p>为配置文件添加 token 信息，设置一个用户条目<br>命令：kubectl config set-credentials camel-sva –token&#x3D;$D –kubeconfig&#x3D;.&#x2F;camel-sva.conf</p>
</li>
<li><p>为配置文件添加权限信息，设置一个 content 条目<br>kubectl config set-context camel-sva@kubernetes –cluster&#x3D;kubernetes –user&#x3D;camel-sva –kubeconfig&#x3D;.&#x2F;camel-sva.conf</p>
</li>
<li><p>为配置文件添加权限信息，设置上下文<br>命令：kubectl config use-context camel-sva@kubernetes –kubeconfig&#x3D;.&#x2F;camel-sva.conf</p>
</li>
</ol>
<p>执行完上述命令后即在当前目录生成配置文件：camel-sva.conf，可 copy 到 kubeconfig对应目录，进行操作。</p>
<img data-src="/posts/fa45/d6da8c845c41.png" class>
<p>使用该配置文件进行 kubectl 命令操作，即可验证用户只拥有对应资源的操作权限。</p>
<img data-src="/posts/fa45/de4222775e67.png" class>

<h4 id="3-API-对象结构"><a href="#3-API-对象结构" class="headerlink" title="3) API 对象结构"></a>3) API 对象结构</h4><img data-src="/posts/fa45/ab8f20ce2acc.png" class>


<h3 id="三、参考学习"><a href="#三、参考学习" class="headerlink" title="三、参考学习"></a>三、参考学习</h3><ol>
<li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/#service-account-permissions">https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/#service-account-permissions</a></li>
<li><a href="https://www.qikqiak.com/k8strain2/security/rbac/#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2">https://www.qikqiak.com/k8strain2/security/rbac/#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/97793056">https://zhuanlan.zhihu.com/p/97793056</a></li>
</ol>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>NetworkPolicy隔离策略</title>
    <url>/posts/8aa0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><blockquote>
<p>一次对当前业务使用ACK 集群的业务调研与改造：针对NetworkPolicy 策略的调研，主要用于新建ACK 集群的网络规划与网络隔离</p>
</blockquote>
<h4 id="1）当前云环境ACK-集群使用现状和痛点"><a href="#1）当前云环境ACK-集群使用现状和痛点" class="headerlink" title="1）当前云环境ACK 集群使用现状和痛点"></a>1）当前云环境ACK 集群使用现状和痛点</h4><ol>
<li><p>UAT&#x2F;线上 环境应用较多，且应用没有做集群内隔离，所有应用全部都在ACK 集群的default namespace 中。没有做到逻辑网络隔离。</p>
</li>
<li><p>集群通过暴露公网SLB 方式进行集群调用，存在浪费资源、管理混乱、安全风险等问题。通过namespace 隔离 + NetworkPolicy 策略通信的方式可以实现集群内部应用自行调用，和VPC 打通之后使用NetworkPolicy 的IP 块策略还可实现跨集群的应用内网调用。</p>
</li>
</ol>
<h4 id="2）实现隔离策略价值"><a href="#2）实现隔离策略价值" class="headerlink" title="2）实现隔离策略价值"></a>2）实现隔离策略价值</h4><ol>
<li><p>降低成本：可以通过网络逻辑隔离的方式将应用已namespace 方式进行隔离，减少冗余的物理设备降低成本。</p>
</li>
<li><p>增加效能：避免复杂且多余的网络设计，使应用之间的调用简单且易于排查。</p>
</li>
</ol>
<span id="more"></span>
<p>问题点：</p>
<ul>
<li>应用SLB 暴露公网方式，白名单管理方式存在多人修改不同步且随意添加白名单带来风险问题。多个SLB 带来的白名单、监听等也存在管理记录困难问题。</li>
<li>通过namespace 隔离，网络规划便于设计（同一VPC 下天然可以通信）。应用间调用完全可以通过集群内部策略实现通信，减少因为网络造成的应用通信异常。</li>
</ul>
<img data-src="/posts/8aa0/7b70de99e5f7.png" class>

<h3 id="二、概念理解"><a href="#二、概念理解" class="headerlink" title="二、概念理解"></a>二、概念理解</h3><h4 id="1）CNI-插件"><a href="#1）CNI-插件" class="headerlink" title="1）CNI 插件"></a>1）CNI 插件</h4><p>k8s 本身没有对容器之间的通信网络进行实现，而是通过 CNI 定义了容器网络的接口的形式，让其他组件实现CNI来实现容器间的网络通信，CNI主要解决什么问题？</p>
<ul>
<li>第一，如何保证每个Pod拥有一个集群内唯一的IP地址？</li>
<li>第二，如何保证不同节点的IP地址划分不会重复？</li>
<li>第三，如何保证跨节点的Pod可以互相通信？</li>
<li>第四，如何保证不同节点的Pod可以与跨节点的主机互相通信？</li>
</ul>
<p>常见的CNI 插件：Calico、Flannel、Terway、Weave Net、 以及 Contiv</p>
<h4 id="2）Terway与Flannel对比"><a href="#2）Terway与Flannel对比" class="headerlink" title="2）Terway与Flannel对比"></a>2）Terway与Flannel对比</h4><p>在创建集群时，ACK提供Terway和Flannel两种网络插件：</p>
<ul>
<li>Terway：是阿里云容器服务ACK自研的网络插件。Terway将阿里云的弹性网卡分配给容器，支持基于Kubernetes标准的网络策略来定义容器间的访问策略，支持对单个容器做带宽的限流。Terway拥有更为灵活的IPAM（容器地址分配）策略，避免地址浪费。如果您不需要使用网络策略（Network Policy），可以选择Flannel，其他情况建议选择Terway。</li>
<li>Flannel：使用的是简单稳定的社区Flannel CNI插件。配合阿里云的VPC的高速网络，能给集群高性能和稳定的容器网络体验。Flannel功能偏简单，支持的特性少。例如，不支持基于Kubernetes标准的网络策略（Network Policy）。更多信息，请参见<a href="https://github.com/coreos/flannel">Flannel</a>。</li>
</ul>
<h4 id="3）NetworkPolicy-实现方式"><a href="#3）NetworkPolicy-实现方式" class="headerlink" title="3）NetworkPolicy 实现方式"></a>3）NetworkPolicy 实现方式</h4><ol>
<li>前置条件：集群安装 CNI（container network interface）插件，阿里云支持两种插件：Flannel（不支持NetworkPolicy）、Terway</li>
<li>ACK 集群开启NetworkPolicy 方式：</li>
</ol>
<ul>
<li>控制台方式操作（简易操作）：需通过阿里云提工单申请</li>
<li>命令行方式操作（kubectl 方式）：无需申请可直接操作。开启方式：<ul>
<li><p>创建Terway集群时可选中** NetworkPolicy支持** 直接开启</p>
<img data-src="/posts/8aa0/2afdc3d69fa9.png" class>
</li>
<li><p>通过修改ConfigMap –&gt; eni-config 文件开启</p>
</li>
</ul>
</li>
</ul>
<img data-src="/posts/8aa0/6bbe6aab7201.png" class>


<ol start="3">
<li>具体实现</li>
</ol>
<ul>
<li><p>NetworkPolicy 支持三种方式进行网络隔离：namespace、ipBlock（CIDR）、Pods</p>
</li>
<li><p>默认情况下非隔离接受任何流量。使用NetworkPolicy 资源配置选中Pod 进入隔离状态（白名单规则），隔离规则有入站（ingress）和出站（egress）规则指定（与iptables概念类似，但不同的是 网络策略是并集累积的规则）</p>
</li>
<li><p>示例配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-network-policy</span></span><br><span class="line">  <span class="comment"># 为namespace 为data的应用设置策略，默认隔离所有流量</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># pod选择器-必需</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">&quot;data_centerevent&quot;</span></span><br><span class="line">      <span class="comment"># role: &quot;&quot;  role分组标签配置为空时表示匹配当前namespace所有pod</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="comment"># 允许 172.17.0.0/16网段，排除 172.17.1.0/24</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="comment"># 允许所有namespace带有&quot;project=apps_project&quot; 标签的所有namesapce Pod流量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">project:</span> <span class="string">apps_project</span></span><br><span class="line">    <span class="comment"># 允许data这个namespace下带有&quot;role=apps&quot; 标签的所有Pod流量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">apps</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="comment"># 允许data这个namespace下，带有&quot;role=data_centerevent&quot;的所有Pod到以下CIDR的流出流量</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三、实现方案与难点"><a href="#三、实现方案与难点" class="headerlink" title="三、实现方案与难点"></a>三、实现方案与难点</h3><h4 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h4><ul>
<li>ACK 集群都为托管版，无法通过自行修改配置更改CNI 插件。且更改CNI 插件可能会导致当前网络模型变动造成未知异常</li>
<li>阿里云ACK 集群有两种CNI 网络插件：Flannel、Terway。阿里云的ACK 集群上面只有Terway 集群支持NetworkPolicy。</li>
<li>已有网络插件无法平滑进行切换，只能通过删除集群重建物理层的方式重新改为 Terway 集群。</li>
</ul>
<h4 id="迁移可行性方案思考"><a href="#迁移可行性方案思考" class="headerlink" title="迁移可行性方案思考"></a>迁移可行性方案思考</h4><ul>
<li>由于当前集群网络规划冲突且复杂，建议使用重建集群方式。新建一个全新规划的集群然后将应用进行迁移：<ul>
<li>无状态应用且无外部调用需求类应用，直接进行部署迁移</li>
<li>部分无依赖&#x2F;弱依赖 应用，使用打包应用群组的方式在新集群进行部署，且新建全新SLB接入新集群应用，通过切换域名解析&#x2F;修改IP 方式将流量切入新集群应用。</li>
</ul>
</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ol>
<li>Kubernetes 官网：<a href="https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/">https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/</a></li>
<li>阿里云官网：<a href="https://help.aliyun.com/document_detail/97621.html">https://help.aliyun.com/document_detail&#x2F;97621.html</a></li>
<li>NetworkPolicy 支持的CNI 插件：<a href="https://www.qikqiak.com/k8strain/network/networkpolicy/">https://www.qikqiak.com/k8strain/network/networkpolicy/</a></li>
<li>阿里云官网（Terway 集群网络规划策略）：<a href="https://help.aliyun.com/document_detail/86500.html">https://help.aliyun.com/document_detail&#x2F;86500.html</a></li>
</ol>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>promotheus组件-grafana大盘配置监控大盘与告警通知</title>
    <url>/posts/9a8h.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><ul>
<li>线上ACK 集群部署了StatefulSet 应用（rabbitMQ），由于rabbitMQ 本身自带的management 后台数据展示较为简陋且没有告警功能，因此考虑接入云上产品监控资源数据且对接告警通知功能，主要通过如下产品实现：<ul>
<li>接入Prometheus 监控+grafana 进行数据图表展示。</li>
<li>利用Arms 产品获取Prometheus 的监控指标，按照设定的阈值进行告警通知功能。</li>
</ul>
</li>
</ul>
<h3 id="二、操作过程"><a href="#二、操作过程" class="headerlink" title="二、操作过程"></a>二、操作过程</h3><h4 id="1）接入Prometheus-组件监控，获取数据指标"><a href="#1）接入Prometheus-组件监控，获取数据指标" class="headerlink" title="1）接入Prometheus 组件监控，获取数据指标"></a>1）接入Prometheus 组件监控，获取数据指标</h4><ul>
<li>进入云产品 <strong>Prometheus监控服务</strong>，选择对应集群。（ACK集群需要先安装Prometheus 监控组件，安装参考：<a href="https://help.aliyun.com/document_detail/161304.html">ARMS Prometheus监控</a>）<img data-src="/posts/9a8h/1.png" class></li>
</ul>
<span id="more"></span>
<ul>
<li><p>选择 组件监控 ，点击添加组件监控，选择要添加的组件。（本次示例为RabbitMQ）</p>
<img data-src="/posts/9a8h/2.png" class>
<img data-src="/posts/9a8h/3.png" class>
</li>
<li><p>添加后即可进入grafana 大盘查看指标数据。验证数据方式可以通过 **curl  xxx:9419&#x2F;metrics ** 获取指标数据，如图:</p>
<img data-src="/posts/9a8h/4.png" class></li>
</ul>
<h4 id="2）grafana-接入数据展示"><a href="#2）grafana-接入数据展示" class="headerlink" title="2）grafana 接入数据展示"></a>2）grafana 接入数据展示</h4><ul>
<li><p>从Pometheus 控制台，点击对应生成的大盘，进入grafana 数据展示界面</p>
<img data-src="/posts/9a8h/5.png" class>
</li>
<li><p>进入grafana Dashboard界面后，需要新增一个panel。操作如下：</p>
<img data-src="/posts/9a8h/6.png" class>
<img data-src="/posts/9a8h/7.png" class>
<img data-src="/posts/9a8h/8.png" class>
</li>
<li><p>在ACK集群查看展示组件相关监控数据：在对应ACK 集群中，选择 <strong>运维管理 – Prometheus监控 –Cloud RABBITMQ</strong> ，即可查看大盘数据。</p>
<img data-src="/posts/9a8h/9.png" class></li>
</ul>
<h4 id="3）创建告警阈值与通知"><a href="#3）创建告警阈值与通知" class="headerlink" title="3）创建告警阈值与通知"></a>3）创建告警阈值与通知</h4><ul>
<li><p>创建钉钉群，并生成钉钉机器人webhook地址。参考：<a href="https://help.aliyun.com/document_detail/251838.html">https://help.aliyun.com/document_detail&#x2F;251838.html</a></p>
</li>
<li><p>在云产品 <strong>Prometheus监控服务</strong> 中，将钉钉机器人添加到告警联系人，使用IM机器人方式。</p>
<img data-src="/posts/9a8h/10.png" class>
</li>
<li><p>在云产品 <strong>应用实时监控服务ARMS – Prometheus监控 – Prometheus告警规则</strong> 中，点击<strong>创建Prometheus告警规则</strong> ，创建告警规则。告警规则详细如图：</p>
<img data-src="/posts/9a8h/11.png" class>
<img data-src="/posts/9a8h/12.png" class>
</li>
<li><p>在云产品 <strong>应用实时监控服务ARMS – 告警管理 – 通知策略</strong> 中，点击<strong>创建通知策略</strong> ，创建告警通知策略。策略配置详细如图：</p>
<img data-src="/posts/9a8h/13.png" class>
<img data-src="/posts/9a8h/14.png" class></li>
</ul>
<h4 id="4）验证告警"><a href="#4）验证告警" class="headerlink" title="4）验证告警"></a>4）验证告警</h4><ul>
<li>将告警规则中PromQL 语句暂时配置为：sum by (queue)(rabbitmq_queue_messages_unacknowledged{app&#x3D;”rabbi-exporter”}) &gt;&#x3D; 0</li>
</ul>
<p>来产生告警</p>
<ul>
<li><p>在云产品 <strong>应用实时监控服务ARMS – 告警管理 – 告警发送历史&#x2F;告警事件历史</strong> 中，搜索告警事件与发送结果：</p>
<img data-src="/posts/9a8h/15.png" class>
<img data-src="/posts/9a8h/16.png" class>
</li>
<li><p>可以看到钉钉群已正常接收告警通知（告警恢复自动发送恢复通知并停止发送告警消息）</p>
<img data-src="/posts/9a8h/17.png" class></li>
</ul>
<h3 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h3><ul>
<li>ACK 集群 RabbitMQ应用告警是创建的临时告警群。后续如需添加其他人或告警通知发布到正式群组按情况进行调整。</li>
</ul>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>ACK-K8S 学习记录</title>
    <url>/posts/754e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、ACK集群网络规划"><a href="#一、ACK集群网络规划" class="headerlink" title="一、ACK集群网络规划"></a>一、ACK集群网络规划</h3><p><a href="https://help.aliyun.com/document_detail/86500.html">https://help.aliyun.com/document_detail&#x2F;86500.html</a></p>
<h3 id="二、RBAC授权"><a href="#二、RBAC授权" class="headerlink" title="二、RBAC授权"></a>二、RBAC授权</h3><p><a href="https://yuque.antfin.com/kifo8h/nee5aa/mvx5t5">https://yuque.antfin.com/kifo8h/nee5aa/mvx5t5</a></p>
<h3 id="三、网络"><a href="#三、网络" class="headerlink" title="三、网络"></a>三、网络</h3><h4 id="容器网络CNI"><a href="#容器网络CNI" class="headerlink" title="容器网络CNI"></a>容器网络CNI</h4><p><a href="https://help.aliyun.com/document_detail/195424.html">https://help.aliyun.com/document_detail&#x2F;195424.html</a></p>
<span id="more"></span>

<h4 id="Service：将一组容器暴露访问接入点，可负载均衡"><a href="#Service：将一组容器暴露访问接入点，可负载均衡" class="headerlink" title="Service：将一组容器暴露访问接入点，可负载均衡"></a>Service：将一组容器暴露访问接入点，可负载均衡</h4><ul>
<li><p><strong>ClusterIP</strong>：在集群内部IP上公开服务。选择此值使服务只能从集群中访问。（默认创建的 ServiceType）</p>
</li>
<li><p><strong>NodePort</strong>：在每个Node的IP上公开静态端口（NodePort）服务。将自动创建NodePort服务到ClusterIP服务的路由。可以通过请求：来从群集外部请求NodePort服务。</p>
</li>
<li><p><strong>LoadBalancer</strong>：使用云提供商的负载均衡器在外部公开服务。将自动创建外部负载均衡器到NodePort和ClusterIP服务的路由</p>
</li>
<li><p><strong>Headless Service</strong>：在Service属性中指定clusterIP字段为None类型。采用Headless Service类型后，Service将没有固定的虚拟IP地址，客户端访问Service的域名时会通过DNS返回所有的后端Pod实例的IP地址，客户端需要采用DNS负载均衡来实现对后端的负载均衡</p>
</li>
<li><p><strong>ExternalName</strong>：将集群外部的域名映射到集群内部的Service上，例如将外部的数据库域名映射到集群内部的Service名，那么就能在集群内部通过Service名直接访问。</p>
</li>
</ul>
<blockquote>
<p><strong>集群信息：</strong></p>
<ul>
<li>集群CIDR（Master、Node ECS实例IP）：172.16.0.0&#x2F;16 </li>
<li>Pod CIDR：10.16.0.0&#x2F;12</li>
<li>Service CIDR：10.32.0.0&#x2F;16</li>
</ul>
<p><strong>Service信息：</strong></p>
<ul>
<li>暴露ClusterIP：10.32.230.55</li>
<li>内部端点：reos-app-file-base-svc:80 TCP</li>
</ul>
</blockquote>
<p><strong>Pod 信息（两个副本）：</strong></p>
<blockquote>
<ul>
<li>IP：10.16.1.41、10.16.3.227</li>
<li>容器内部启动端口：8080</li>
</ul>
</blockquote>
<p><strong>NodePort信息（两个Node节点、使用ClusterIP模式时没有该信息）：</strong></p>
<blockquote>
<ul>
<li>NodeIP：172.16.9.150、172.16.9.64</li>
<li>公开的静态端口：30152、30144</li>
</ul>
</blockquote>
<p><strong>LoadBanlancer 信息（公网或私网）：</strong></p>
<blockquote>
<ul>
<li>暴露公网IP：112.124.13.114</li>
<li>外部端点：112.124.13.114:80</li>
</ul>
<p><strong>此时，可通过四种方式进行应用的请求（最终流量到达一致，都会到容器内部）：</strong></p>
<ol>
<li>集群内部请求 ServiceIP：10.32.230.55:80 或 reos-app-file-base-svc:80（解析需Coredns组件）</li>
<li>集群内部请求 PodIP（随时变化，一般不使用）：10.16.1.41:8080 或 10.16.3.227:8080</li>
<li>集群内部或外部请求 NodeIP：172.16.9.150:30152 或 172.16.9.64:30144</li>
<li>集群内部或外部请求 SLB IP：112.124.13.114:80 （注意集群内部访问时要修改外部策略 local –&gt; Cluster）</li>
</ol>
<p><strong>查看端点信息：kubectl get endpoints&#x2F;xxxxx -owide</strong></p>
</blockquote>
<img data-src="/posts/754e/k8s1.png" class>


<h4 id="Ingress：将集群内的-Service-对外暴露7层的访问接入点"><a href="#Ingress：将集群内的-Service-对外暴露7层的访问接入点" class="headerlink" title="Ingress：将集群内的 Service 对外暴露7层的访问接入点"></a>Ingress：将集群内的 Service 对外暴露7层的访问接入点</h4><p>如：前后端使用 &#x2F;static&#x2F; 、 &#x2F;apis&#x2F; 的不同 URL ，使用 Ingress 匹配规则并进行对应后端的反向代理</p>
<img data-src="/posts/754e/k8s2.png" class>

<h4 id="Coredns：服务发现DNS，实现不同部署环境访问同样的访问入口"><a href="#Coredns：服务发现DNS，实现不同部署环境访问同样的访问入口" class="headerlink" title="Coredns：服务发现DNS，实现不同部署环境访问同样的访问入口"></a>Coredns：服务发现DNS，实现不同部署环境访问同样的访问入口</h4><ul>
<li>通过 Service 的服务名解析出 ClusterIP</li>
<li>通过 StatefulSet 的 Pod 名解析出 Pod 的 IP</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>相关阿里云资源：<a href="https://help.aliyun.com/product/27706.html">VPC</a>、<a href="https://help.aliyun.com/product/27537.html">SLB</a></li>
<li><a href="https://help.aliyun.com/document_detail/97467.html">Terway 与 Flannel对比</a></li>
</ul>
<h3 id="四、存储"><a href="#四、存储" class="headerlink" title="四、存储"></a>四、存储</h3><img data-src="/posts/754e/k8s3.png" class>
<h4 id="容器存储接口CSI-Plugin-组件"><a href="#容器存储接口CSI-Plugin-组件" class="headerlink" title="容器存储接口CSI-Plugin 组件"></a>容器存储接口CSI-Plugin 组件</h4><ul>
<li>云盘存储卷</li>
<li>容器网络文件系统</li>
<li>NAS 存储卷</li>
<li>OSS 存储卷</li>
<li>CPFS 存储卷</li>
<li>本地存储卷</li>
<li>容器存储监控&amp;运维</li>
</ul>
<h4 id="存储FlexVolume-组件"><a href="#存储FlexVolume-组件" class="headerlink" title="存储FlexVolume 组件"></a>存储FlexVolume 组件</h4><ul>
<li>云盘存储卷</li>
<li>NAS 存储卷</li>
<li>OSS 存储卷</li>
<li>CPFS 存储卷</li>
<li>持久化存储卷声明</li>
</ul>
<h3 id="五、应用"><a href="#五、应用" class="headerlink" title="五、应用"></a>五、应用</h3><h4 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h4><ul>
<li>无状态工作 Deployment</li>
<li>有状态工作 StatefulSet<ul>
<li>特性：Pod 一致性、稳定的持久化存储、稳定的网络标志（hostname）、稳定的次序（副本的数字序号）</li>
</ul>
</li>
<li>守护进程集 DaemenSet<ul>
<li>保证每个节点上都运行一个容器副本</li>
<li>部署集群日志、监控或其他系统管理应用</li>
</ul>
</li>
<li>任务 Job<ul>
<li>仅执行一次性任务，保证批处理任务一个或多个 Pod 成功结束</li>
<li>支持的Job类型：非并行、固定结束次数、工作队列并行Job、固定结束次数的并行Job</li>
</ul>
</li>
<li>定时任务 CronJob<ul>
<li>执行周期性和重复性任务（如备份操作或发送邮件），通过时间调度</li>
</ul>
</li>
<li>容器组<ul>
<li>Pod：最小部署单元，由单个容器（实际docker 容器）或几个紧耦合的容器组成</li>
</ul>
</li>
<li>自定义资源<ul>
<li>自定义资源定义拓展 K8S API</li>
<li>查看集群中所有API 组和包含的资源类型</li>
</ul>
</li>
</ul>
<h4 id="镜像（ACR仓库）"><a href="#镜像（ACR仓库）" class="headerlink" title="镜像（ACR仓库）"></a>镜像（ACR仓库）</h4><ul>
<li>镜像签名组件：kritis-validation-hook</li>
<li>镜像免密拉取组件：aliyun-acr-credential-helper</li>
</ul>
<h4 id="配置项-Configmap-与保密字典-Secret"><a href="#配置项-Configmap-与保密字典-Secret" class="headerlink" title="配置项 Configmap 与保密字典 Secret"></a>配置项 Configmap 与保密字典 Secret</h4><ul>
<li>配置项管理和使用<ul>
<li>控制台&#x2F;YAML  创建管理Configmap 资源</li>
<li>使用：设置Pod 环境变量、设置命令行参数、数据卷中使用</li>
</ul>
</li>
<li>保密字典管理和使用<ul>
<li>控制台&#x2F;YAML 创建管理Secret 资源</li>
<li>使用：设置Pod 环境变量、数据卷中使用</li>
</ul>
</li>
</ul>
<h4 id="应用调度与部署"><a href="#应用调度与部署" class="headerlink" title="应用调度与部署"></a>应用调度与部署</h4><ul>
<li>调度应用Pod 至指定节点：通过设置节点<strong>标签</strong>，配置nodeSelector 强制约束Pod 调度到指定节点（控制台给节点添加标签，然后Pod 启动的YAML 模板 spec –&gt; nodeSelector –&gt; gourp 配置为新增的标签名）</li>
<li>Descheduler 组件对集群Pod 调度优化（通过策略设置）<ul>
<li>删除重复Pod，确保只有一个Pod 与同一节点运行的ReplicaSet、Replication Controller、StatefulSet、Job 关联</li>
<li>删除违反Pod 间反亲和性的Pod</li>
<li>驱逐其他节点Pod 到未充分利用的节点</li>
<li>删除重启次数过多的Pod</li>
</ul>
</li>
<li>应用触发器重新部署应用：控制台生成触发器URL，通过请求URL 触发重新部署（可通过curl 或集成开发语言）</li>
<li>Helm 应用部署<ul>
<li>Chart：Helm包，包含运行应用所需的镜像、依赖和资源定义、集群中服务定义，类似APT 的dpkg 或YUM 的rpm 文件。</li>
<li>Release：运行Chart 的实例。同一集群Chart 可以安装多次，每次安装都会创建一个release（如一个MySQL Chart 安装两次，就会在服务器上产生两个release 版本的数据库）。</li>
<li>Repository： 用于发布和存储Chart 的存储库。</li>
<li>Helm 组件：Helm CLI 客户端工具、Tiller 服务端组件、Repository 存储库（HTTP协议访问）。</li>
</ul>
</li>
<li>控制台方式&#x2F;YAML方式 部署、发布和监控应用</li>
</ul>
<h4 id="使用AHAS对应用进行高可用防护"><a href="#使用AHAS对应用进行高可用防护" class="headerlink" title="使用AHAS对应用进行高可用防护"></a>使用AHAS对应用进行高可用防护</h4><p><a href="https://help.aliyun.com/document_detail/193575.html">https://help.aliyun.com/document_detail&#x2F;193575.html</a></p>
<h3 id="六、组件"><a href="#六、组件" class="headerlink" title="六、组件"></a>六、组件</h3><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ul>
<li><p>系统组件</p>
<ul>
<li>Kube API Server：集群总线和入口网关。</li>
<li>Kube Controller Manager：集群内部资源管理器。</li>
<li>Cloud Controller Manager：提供集群与阿里云基础产品对接能力，如 CLB、VPC等。<h4 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h4></li>
</ul>
</li>
<li><p>可选组件</p>
<ul>
<li>appcenter：提供统一管理多集群应用部署和应用生命周期的应用中心组件。</li>
<li>progressive-delivery-tool：提供应用渐进式灰度发布的组件。<h4 id="日志与监控"><a href="#日志与监控" class="headerlink" title="日志与监控"></a>日志与监控</h4></li>
</ul>
</li>
<li><p>系统组件</p>
<ul>
<li>alicloud-monitor-controller：ACK提供对接云监控的系统组件。</li>
<li>metrics-server：ACK基于社区开源监控组件进行改造和增强的监控采集和离线组件，并提供Metrics API进行数据消费，提供HPA的能力。</li>
</ul>
</li>
<li><p>可选组件</p>
<ul>
<li>ack-node-problem-detector：ACK基于社区开源项目进行改造和增强的集群节点异常事件监控组件，以及对接第三方监控平台功能的组件。</li>
<li>ags-metrics-collector：为基因计算客户使用的监控服务组件，可以通过该组件监控基因工作流中各个节点资源使用的详细信息。</li>
<li>ack-arms-prometheus：使用ARMS Prometheus实现容器服务集群监控。</li>
<li>logtail-ds：使用日志服务采集Kubernetes容器日志。</li>
<li>logtail-windows：ACK集群上使用的容器日志收集插件，用于在阿里云上配合SLS服务对Windows容器进行日志收集。<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4></li>
</ul>
</li>
<li><p>可选组件</p>
<ul>
<li>csi-plugin：支持数据卷的挂载、卸载功能。创建集群时，如果选择CSI插件实现阿里云存储的接入能力的话，默认安装该组件。</li>
<li>csi-provisioner：支持数据卷的自动创建能力。创建集群时，如果选择CSI插件实现阿里云存储的接入能力的话，默认安装该组件。</li>
<li>storage-operator：用于管理存储组件的生命周期。</li>
<li>alicloud-disk-controller：支持自动创建云盘卷。</li>
<li>Flexvolume：社区较早实现的存储卷扩展机制。Flexvolume支持数据卷的挂载、卸载功能。创建集群时，如果选择Flexvolume插件实现阿里云存储的接入能力的话，默认安装该组件。</li>
</ul>
</li>
</ul>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul>
<li>系统组件<ul>
<li>CoreDNS：ACK集群中默认采用的DNS服务发现插件，其遵循Kubernetes DNS-Based Service Discovery规范。</li>
<li>Nginx Ingress Controller：Nginx Ingress Controller解析Ingress的转发规则。Ingress Controller收到请求，匹配Ingress转发规则转发到后端Service。</li>
<li>managed-kube-proxy-windows：ACK托管版集群上使用的容器化kube-proxy，用于管理Windows节点上Service的访问入口，包括集群内Pod到Service的访问和集群外访问Service。</li>
</ul>
</li>
<li>可选组件<ul>
<li>Terway :  阿里云开源的基于专有网络VPC的容器网络接口CNI插件，支持基于Kubernetes标准的网络策略（NetworkPolicy）来定义容器间的访问策略。创建集群时，如果选择Terway网络插件实现集群内部网络互通的话，默认安装该组件。</li>
<li>Flannel：容器网络接口CNI插件，在阿里云上使用的Flannel网络模式采用阿里云VPC模式。创建集群时，如果选择Flannel网络插件实现集群内部网络互通的话，默认安装该组件。</li>
<li>ACK NodeLocal DNSCache：基于社区开源项目NodeLocal DNSCache的一套DNS本地缓存解决方案。</li>
<li>kube-flannel-ds-windows：ACK托管版集群上使用的容器网络插件，用于构建适合Windows容器通讯的L2Bridge集群网络。</li>
</ul>
</li>
</ul>
<img data-src="/posts/754e/k8s4.png" class>

<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a><a href="https://help.aliyun.com/document_detail/277412.html#title-nq4-jps-k41">安全</a></h4><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><a href="https://help.aliyun.com/document_detail/277412.html#title-iib-fx3-2hl">其他</a></h4><h3 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h3><h4 id="K8S-集群-NetworkPolicy-策略"><a href="#K8S-集群-NetworkPolicy-策略" class="headerlink" title="K8S 集群 NetworkPolicy 策略"></a><a href="https://yuque.antfin.com/kifo8h/nee5aa/bzg9vq">K8S 集群 NetworkPolicy 策略</a></h4><ul>
<li>Pod 和 Pod 通信通过三个标识符组合来辨识：</li>
</ul>
<p>1、其他被允许的 Pods（Pod 无法阻塞自身的访问）<br>2、被允许的 namespace<br>3、IP 组块 （Pod 本身所在的 Node 和 Pod  IP通信默认允许通信）</p>
<ul>
<li>默认情况下，Pod 非隔离。 被 NetworkPolicy 选中进入隔离状态。</li>
<li>NetworkPolicy 策略不会冲突，累积策略。多个策略作用于一个Pod时，Pod 的入站&#x2F;出站策略取所有策略的并集</li>
<li>两个 Pod 之间通信时，需要源端Pod上的出站（Egress）规则和目标端 Pod 上的入站（Ingress）规则都要允许该流量。</li>
<li>ACK只支持 Terway 网络模式，不支持 Flannel 网络模式</li>
</ul>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>VPC 网络规划案例</title>
    <url>/posts/64a8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="网段规划概述"><a href="#网段规划概述" class="headerlink" title="网段规划概述"></a>网段规划概述</h3><h4 id="1）规划网段的目的"><a href="#1）规划网段的目的" class="headerlink" title="1）规划网段的目的"></a>1）规划网段的目的</h4><ul>
<li>方便查看管理，相当于对某一个&#x2F;多个IDC 机房的IP 规划，根据IP 地址可以一目了然的判断出归属。</li>
<li>便于同集群&#x2F;VPC 内网段判断网络、路由走向、以及网络隔离策略（白名单）。</li>
<li>区分多VPC&#x2F;网络 环境，方便在打通网络时区分子网网段。</li>
</ul>
<h4 id="2）规范化设计的方式"><a href="#2）规范化设计的方式" class="headerlink" title="2）规范化设计的方式"></a>2）规范化设计的方式</h4><p>首先需要分清两类，是否有ACK 等集群类资源单独规划：</p>
<ol>
<li>如无集群资源（即只有RDS、ECS 等常规资源），按正常内网网段定义VPC与交换机即可</li>
<li>有集群资源，最好划分单独交换机部署常规资源，<strong>独立交换机</strong>部署集群资源。</li>
</ol>
<span id="more"></span>

<p>由于线上部署，或者未来趋势 基本云上都会已集群方式存在，因此只讨论第二种方式。<br>网段设计规范：</p>
<ul>
<li>VPC可使用的私网网段：192.168.0.0&#x2F;16、10.0.0.0&#x2F;8、172.16.0.0&#x2F;12及其子网，每个专有网络只能指定一个网段。</li>
<li>交换机可使用的网段：需要&lt;&#x3D; VPC网段（子集）</li>
</ul>
<img data-src="/posts/64a8/vpc1.png" class>

<ul>
<li>VPC数量：创建多个VPC 时尽量使用不同网段</li>
<li>集群数量：同账号下部署多集群时尽量使用不同网段</li>
<li>如有ACK 集群资源时，需判断集群网络插件模式<ul>
<li>非Terway 插件时，需要三个私网网段，如：10.1.0.0&#x2F;16（VPC-vswitch）、192.168.0.0&#x2F;24（Pod 使用）、192.168.10.0&#x2F;24（Service 使用）</li>
<li>使用Terway 插件时，需要两个私网网段，如：10.16.0.0&#x2F;8（VPC-vswitch + Pod）、192.168.0.0&#x2F;24（Service 使用）</li>
</ul>
</li>
</ul>
<h4 id="个人建议"><a href="#个人建议" class="headerlink" title="**个人建议"></a>**个人建议</h4><ul>
<li><p>同账号下（同环境）选择 192.168.0.0&#x2F;16、10.0.0.0&#x2F;0、172.16.0.0&#x2F;12 进行VPC 创建组网。</p>
<ul>
<li>不同集群与云产品资源之间使用子交换机分割。</li>
<li>使用云产品白名单或其他网络插件做网络隔离策略。</li>
</ul>
</li>
<li><p>不同账号（如日常、线上）可复用同网段进行组网（一般不存在跨环境调用）。</p>
</li>
<li><p>当前环境网络组网信息（建议后续都使用Terway 插件）：</p>
<ul>
<li><p>日常环境网络架构</p>
<img data-src="/posts/64a8/vpc2.png" class>
</li>
<li><p>线上网络架构（集群与集群、集群与云产品，通过私网的交换机网段进行隔离）</p>
</li>
</ul>
</li>
</ul>
<img data-src="/posts/64a8/vpc3.png" class>


<h3 id="线上实际案例"><a href="#线上实际案例" class="headerlink" title="线上实际案例"></a>线上实际案例</h3><h4 id="1）案例1"><a href="#1）案例1" class="headerlink" title="1）案例1"></a>1）案例1</h4><img data-src="/posts/64a8/vpc4.png" class>

<ul>
<li>VPC：10.0.0.0&#x2F;8 （复用线上VPC）</li>
<li>交换机：新建4 台交换机<ul>
<li>test-swc-10_200_0_0_20  （可用区 1）</li>
<li>test-swc-10_200_16_0_20 （可用区 2）</li>
<li>test-swc-10_200_64_0_19 （可用区 1）</li>
<li>test-swc-10_200_96_0_19 （可用区 2）</li>
</ul>
</li>
<li>集群CIDR规划<ul>
<li>Node CIDR：<ul>
<li>10.200.0.0&#x2F;20</li>
<li>10.200.16.0&#x2F;20</li>
</ul>
</li>
<li>Pod CIDR：<ul>
<li>10.200.64.0&#x2F;19</li>
<li>10.200.96.0&#x2F;19</li>
</ul>
</li>
<li>Service CIDR：<ul>
<li>172.31.0.0&#x2F;16<blockquote>
<p>注意：</p>
<ul>
<li>Node 和Pod 交换机如要高可用选择不同可用区时，需要每个可用区都有Node 和Pod 可使用的交换机。</li>
<li>Service 网段不能与VPC 网段 及VPC 内已有Kubernetes 集群使用的网段重复。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2）相关文档与工具"><a href="#2）相关文档与工具" class="headerlink" title="2）相关文档与工具"></a>2）相关文档与工具</h4><ul>
<li><p><a href="https://help.aliyun.com/document_detail/189596.html">云企业网工作原理与操作</a></p>
</li>
<li><p>VPN网关原理与操作：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1824924">IPSec VPN 技术原理</a></li>
<li><a href="https://help.aliyun.com/document_detail/65072.html">阿里云官方操作文档</a></li>
</ul>
</li>
<li><p><a href="https://www.bejson.com/convert/subnetmask/">子网计算在线工具</a></p>
</li>
<li><p>架构图</p>
</li>
</ul>
<p><img data-src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/21956377/1646207048171-c0f5a83d-b982-4e85-ab78-f724882be069.png#clientId=ufadced67-c1c1-4&from=ui&id=u1dc1cab7&margin=%5Bobject%20Object%5D&name=%E6%80%BB%E4%BD%93%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png&originHeight=1993&originWidth=4131&originalType=binary&ratio=1&size=515776&status=done&style=none&taskId=uffed0b55-26c9-4f1d-b577-67c4f6f81ec" alt="总体网络架构.png"></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云-RAM 与 STS 权限</title>
    <url>/posts/fdc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>当通过OpenApi接口来调用云资源时（即替代控制台的操作），当前的方式有两种：</p>
<ul>
<li>通过 AK+SK 方式直接调用，只要该AK所属的账号有相关权限即可调用对应资源（授权分为系统策略和自定义策略）</li>
<li>阿里云账号（RAM用户）&#x2F;阿里云服务（ECS等）&#x2F;身份提供商（SSO） 通过扮演角色获取角色的临时令牌（即通过调用AssumeRole接口），通过该临时令牌（临时令牌可设定会话时间），通过 STS接口获取到的 临时AK+临时SK+临时STSToken 进行调用对应资源</li>
</ul>
<h3 id="二、官方概念介绍"><a href="#二、官方概念介绍" class="headerlink" title="二、官方概念介绍"></a>二、官方概念介绍</h3><ol>
<li>STS概念</li>
</ol>
<ul>
<li>阿里云STS（Security Token Service）是阿里云提供的一种临时访问权限管理服务。RAM提供RAM用户和RAM角色两种身份。其中，RAM角色不具备永久身份凭证，而只能通过STS获取可以自定义时效和访问权限的临时身份凭证，即安全令牌（STS Token）</li>
</ul>
<span id="more"></span>
<p>建议阅读：<a href="https://help.aliyun.com/document_detail/28756.html">https://help.aliyun.com/document_detail&#x2F;28756.html</a></p>
<ol start="2">
<li>RAM概念</li>
</ol>
<ul>
<li>RAM用户：身份实体，可访问阿里云资源的账号或程序；创建时可选择登录场景、AccessKey场景（通过程序调用API）。</li>
<li><strong>RAM角色</strong>：虚拟用户，向信任的RAM实体账号进行授权（根据STS令牌颁发短时有效的临时访问token）；创建角色后会生成Arn描述符（角色的描述符：每个RAM角色存在唯一值且遵循阿里云arn命名规范）。</li>
<li>RAM权限策略：一组权限集，使用简单的Policy语法进行描述（分为系统策略和自定义策略）；权限策略是实际细分授权资源集、操作集、授权条件的描述。</li>
</ul>
<img data-src="/posts/fdc/ram1.png" class>

<blockquote>
<p>创建RAM角色时有三种类型：</p>
<ul>
<li><strong>阿里云账号</strong>：允许RAM用户所扮演的角色。扮演角色的RAM用户可以属于自己的阿里云账号，也可以属于其他阿里云账号。此类角色主要用来解决跨账号访问和临时授权问题</li>
<li><strong>阿里云服务</strong>：允许云服务所扮演的角色。此类角色主要用于授权云服务代理您进行资源操作（服务又分为两种）<ul>
<li>普通服务角色：您需要自定义角色名称，选择受信服务，并自定义权限策略</li>
<li>服务关联角色：您只需选择受信的云服务，云服务会自带预设的角色名称和权限策略</li>
<li>两种服务角色没太大区别，服务关联角色会多一个预设的配置（一般服务角色用户阿里云跨服务间的调用，例如ECS的授予&#x2F;收回RAM角色功能、RDS云服务调用KMS角色加密等，从某个云产品调用另一个云产品的授权）</li>
</ul>
</li>
</ul>
</blockquote>
<img data-src="/posts/fdc/ram2.png" class>
<blockquote>
<ul>
<li><strong>身份提供商</strong>：允许可信身份提供商下的用户所扮演的角色。此类角色主要用于实现与阿里云的单点登录（SSO）</li>
</ul>
<p><strong>常用的RAM角色一般为创建 阿里云账号 方式（OSS官方推荐使用）</strong></p>
<ul>
<li>授权RAM角色介绍：<a href="https://help.aliyun.com/document_detail/116819.html">https://help.aliyun.com/document_detail&#x2F;116819.html</a></li>
<li>OSS官方推荐使用 阿里云账号 方式：<a href="https://help.aliyun.com/document_detail/100624.html">https://help.aliyun.com/document_detail&#x2F;100624.html</a></li>
</ul>
</blockquote>
<h3 id="三、创建STS角色，自定义授权OSS功能测试"><a href="#三、创建STS角色，自定义授权OSS功能测试" class="headerlink" title="三、创建STS角色，自定义授权OSS功能测试"></a>三、创建STS角色，自定义授权OSS功能测试</h3><p>1）测试账号信息<br>账号：<a href="mailto:&#x64;&#x65;&#118;&#x6f;&#x70;&#115;&#95;&#116;&#101;&#x73;&#x74;&#x40;&#120;&#x78;&#120;&#x2e;&#x6f;&#110;&#x61;&#108;&#x69;&#121;&#x75;&#110;&#46;&#x63;&#111;&#x6d;">&#x64;&#x65;&#118;&#x6f;&#x70;&#115;&#95;&#116;&#101;&#x73;&#x74;&#x40;&#120;&#x78;&#120;&#x2e;&#x6f;&#110;&#x61;&#108;&#x69;&#121;&#x75;&#110;&#46;&#x63;&#111;&#x6d;</a><br>AK：xxxxx<br>SK：xxxxx<br>ARN：acs:ram::xxxxx:role&#x2F;xxx-sts<br>OSS Bucket名称：oss-test<br>OSS授权目录：dir111&#x2F;dir111_secondline1&#x2F;</p>
<p>2）进行授权</p>
<ul>
<li>创建RAM用户（子账号），生成AK SK （此步骤忽略）</li>
<li>测试账号添加STS权限</li>
</ul>
<img data-src="/posts/fdc/ram3.png" class>

<ul>
<li>添加权限策略，使用自定义策略授权（OSS官方示例Policy：<a href="https://help.aliyun.com/document_detail/266627.html">https://help.aliyun.com/document_detail&#x2F;266627.html</a>）</li>
</ul>
<img data-src="/posts/fdc/ram4.png" class>

<ul>
<li>添加RAM角色并授权Policy</li>
</ul>
<img data-src="/posts/fdc/ram5.png" class>

<img data-src="/posts/fdc/ram6.png" class>

<p>3）测试验证（控制台无法登录RAM账号验证权限情况下，可以使用ossutil或ossbrowser工具进行验证）</p>
<ul>
<li>ossutil使用：<a href="https://help.aliyun.com/document_detail/50451.html">https://help.aliyun.com/document_detail&#x2F;50451.html</a></li>
</ul>
<img data-src="/posts/fdc/ram7.png" class>

<ul>
<li>ossbrowser使用：<a href="https://help.aliyun.com/document_detail/92268.html">https://help.aliyun.com/document_detail&#x2F;92268.html</a></li>
</ul>
<p>4）验证列举和其他相关权限无误后，将ARN信息提供研发即可</p>
<blockquote>
<p>权限流程：</p>
<ol>
<li>客户端程序&#x2F;调用端发起扮演角色，此时在进入实际要获取的角色权限前，需要通过调用AssumeRole接口返回STS凭证（调用STS接口需要<strong>AliyunSTSAssumeRoleAccess</strong>权限，因此对应RAM账号需要授权该系统策略）</li>
<li>通过返回的STS临时凭证（临时AK+临时SK+临时token）发起相关云资源接口的调用</li>
<li>客户端使用STS发起调用时，会验证两个部分的权限策略Policy （注意：最后的权限取这两个权限Policy的交集）</li>
</ol>
<ul>
<li>STS扮演的角色本身授权的权限策略是否拥有对应云资源的权限（系统或自定义的Policy）</li>
<li>SDK&#x2F;API调用时传入的policy_text参数值，在构造调用请求时传入（<a href="https://help.aliyun.com/document_detail/100624.html">https://help.aliyun.com/document_detail&#x2F;100624.html</a><img data-src="/posts/fdc/ram8.png" class></li>
</ul>
</blockquote>
<h3 id="四、结合实际需求"><a href="#四、结合实际需求" class="headerlink" title="四、结合实际需求"></a>四、结合实际需求</h3><ol>
<li><p>开发提出需求：需要某一个oss bucket的STS ARN信息</p>
</li>
<li><p>需要相关信息：</p>
</li>
</ol>
<ul>
<li>oss bucket具体需授权目录，必须</li>
<li>endpoint: oss bucket所属区域，非必须</li>
<li>bucket-name: oss bucket名称，必须</li>
<li>调用OSS RAM账号，必须</li>
</ul>
<ol start="3">
<li>通过提供信息进行创建RAM角色、Policy策略新建（注意oss 细粒度的策略）、授权策略到RAM角色中，最后将新建的RAM角色的ARN描述符信息提供给研发。</li>
</ol>
]]></content>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ 简述与使用</title>
    <url>/posts/9bae.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、RabbitMQ-介绍"><a href="#一、RabbitMQ-介绍" class="headerlink" title="一、RabbitMQ 介绍"></a>一、RabbitMQ 介绍</h3><h4 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h4><p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p>
<p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p>
<h4 id="为何用消息队列"><a href="#为何用消息队列" class="headerlink" title="为何用消息队列"></a>为何用消息队列</h4><p>以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。</p>
<p>以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。</p>
<span id="more"></span>

<h4 id="RabbitMQ-特点"><a href="#RabbitMQ-特点" class="headerlink" title="RabbitMQ 特点"></a>RabbitMQ 特点</h4><ul>
<li>协议</li>
</ul>
<p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p>
<ul>
<li>具体特点<ul>
<li>可靠性：持久化、传输确认、发布确认机制。</li>
<li>灵活的路由：Exchange 路由消息</li>
<li>消息集群：多个RabbitMQ 组成集群，形成逻辑Broker</li>
<li>高可用</li>
<li>多种协议</li>
<li>多语言客户端</li>
<li>UI 管理后台</li>
<li>跟踪机制：消息跟踪</li>
<li>插件机制</li>
</ul>
</li>
</ul>
<h4 id="RabbitMQ-概念模型"><a href="#RabbitMQ-概念模型" class="headerlink" title="RabbitMQ 概念模型"></a>RabbitMQ 概念模型</h4><ul>
<li>基本概念（<a href="https://help.aliyun.com/document_detail/101628.html">详细名词解释</a>）</li>
</ul>
<p>Vhost：虚拟主机，逻辑上分隔RabbitMQ 实例。<br>Broker：服务器实体，多个RabbitMQ 实例形成的集群。</p>
<p>Connection：物理连接，如TCP 连接（应用与云上RabbitMQ 实例连接时大约需要15个TCP 报文交互）<br>Channel：信道，多路复用Connection （TCP 连接）</p>
<p>Publisher：应用程序，向Exchange 发布消息。<br>Consumer：应用程序，从Queue 接收消息。</p>
<p>Message：由消息头+消息体组成。消息头属性有：routing-key（路由键）、priority（优先级）、delivery-mode（是否持久性存储消息）<br>Exchange：交换器，接收消息并路由到Queue。<br>Queue：消息队列，保存消息直到发送给Consumer。消息可存在多个队列。<br>Binding：绑定，基于routing-key 将Queue 与Exchange 关联，类似一条路由规则。</p>
<img data-src="/posts/9bae/rbmq1.png" class>

<ul>
<li>AMQP 协议消息路由</li>
</ul>
<p>AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p>
<img data-src="/posts/9bae/rbmq2.png" class>

<ul>
<li>Exchange 类型</li>
</ul>
<p>headers（已废弃）</p>
<p>direct：Message中routing-key 值与Binding 中binding-key 一致，则发入对应Queue。（完全匹配、单播方式）</p>
<img data-src="/posts/9bae/rbmq3.png" class>

<p>fanout：不处理routing-key，将消息发到所有与Exchange 绑定的Queue。（广播方式）</p>
<img data-src="/posts/9bae/rbmq4.png" class>

<p>topic：模式匹配routing-key 属性，Queue 需要通过通配符绑定到某个模式上。（类似于正则匹配到主题）</p>
<img data-src="/posts/9bae/rbmq5.png" class>

<p>JMS Queue Exchange：云上产品支持（与direct 类似）<br>JMS topic Exchange：云上产品支持（与topic 类似）</p>
<h4 id="RabbitMQ-安装与运行、集群配置"><a href="#RabbitMQ-安装与运行、集群配置" class="headerlink" title="RabbitMQ 安装与运行、集群配置"></a>RabbitMQ 安装与运行、集群配置</h4><p><a href="https://www.jianshu.com/p/79ca08116d57">https://www.jianshu.com/p/79ca08116d57</a></p>
<blockquote>
<p>云上实例默认开通都为集群模式</p>
</blockquote>
<h3 id="二、云上最佳实践与业务结合"><a href="#二、云上最佳实践与业务结合" class="headerlink" title="二、云上最佳实践与业务结合"></a>二、云上最佳实践与业务结合</h3><h4 id="RabbitMQ-使用最佳实践"><a href="#RabbitMQ-使用最佳实践" class="headerlink" title="RabbitMQ 使用最佳实践"></a>RabbitMQ 使用最佳实践</h4><ul>
<li>云上使用方式：直接创建对应地域的RabbitMQ 实例即可。</li>
</ul>
<p>当前日常环境实例规格限制（当前并未使用RabbitMQ 云产品）</p>
<img data-src="/posts/9bae/rbmq6.png" class>

<ul>
<li><p>云上实例高级特性</p>
<ul>
<li>消息重试</li>
<li>延时消息（订单延时支付场景）</li>
<li>死信Exchange</li>
<li>消息存活时间</li>
</ul>
</li>
<li><p>ACK 集群内部署RabbitMQ 使用方式</p>
<ul>
<li><p>创建RabbitMQ 的StatefulSet ，注意持久化存储配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">camel-k-rabbitmq-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podManagementPolicy:</span> <span class="string">OrderedReady</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">camel-k-rabbitmq-test</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">camel-k-rabbitmq-test-svc</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">camel-k-rabbitmq-test</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OPENSSL_SOURCE_SHA256</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">f89199be8b23ca45fc7cb9f1d8d3ee67312318286ad030f5316aca6462db6c96</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OPENSSL_PGP_KEY_IDS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0x8657ABB260F056B1E5190839D9C4D26D0E604491</span> <span class="number">0x5B2545DAB21995F4088CEFAA36CEE4DEB00CFE33</span></span><br><span class="line">            <span class="number">0xED230BEC4D4F2518B9D7DF41F0DB4D21C1D35231</span> <span class="number">0xC1F33DD8CE1D4CC613AF14DA9195C48241FBF7DD</span></span><br><span class="line">            <span class="number">0x7953AC1FBC3DC8B3B292393ED5E9E43F7DF9EE8C</span> <span class="number">0xE5E52560DD91C556DDBDA5D02064C53641C25E5D</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">OTP_SOURCE_SHA256</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">af0f1928dcd16cd5746feeca8325811865578bf1a110a443d353ea3e509e6d41</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RABBITMQ_DATA_DIR</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">/var/lib/rabbitmq</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RABBITMQ_PGP_KEY_ID</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0x0A9AF2115F4687BD29803A206B73A36E6026DFCA</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RABBITMQ_HOME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">/opt/rabbitmq</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RABBITMQ_LOGS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">HOME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">/var/lib/rabbitmq</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LANG</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">C.UTF-8</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LANGUAGE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">C.UTF-8</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LC_ALL</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">C.UTF-8</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">rabbitmq:3.9.11-management</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">camel-k-rabbitmq-test</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">15671</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">port1</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">15672</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">port2</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">15691</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">15692</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">25672</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">4369</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5671</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5672</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">        <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">        <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/rabbitmq</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">volume-image-0</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">      <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/rabbitmq</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">volume-image-0</span></span><br><span class="line">  <span class="attr">updateStrategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>暴露RabbitMQ 的管理UI 后台，以及集群内部 5672 server端端口（建议从ACK 控制台新建，使用yaml 文件新建Service 会新建SLB）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">rabbitmq-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">192.168</span><span class="number">.87</span><span class="number">.198</span></span><br><span class="line">  <span class="attr">clusterIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.87</span><span class="number">.198</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">32166</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">5672</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">camel-k-rabbitmq-test</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>

<h4 id="业务测试验证"><a href="#业务测试验证" class="headerlink" title="业务测试验证"></a>业务测试验证</h4><blockquote>
<p>Python 使用RabbitMQ 教程：<a href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html">https://www.rabbitmq.com/tutorials/tutorial-one-python.html</a></p>
</blockquote>
<ol>
<li>创建Vhost、Exchange（topic 类型）</li>
</ol>
<img data-src="/posts/9bae/rbmq7.png" class>
<img data-src="/posts/9bae/rbmq8.png" class>
<img data-src="/posts/9bae/rbmq9.png" class>



<ol start="2">
<li>使用Python SDK 进行接收消息验证</li>
</ol>
<p>Publisher</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;xxx.com&#x27;</span>, <span class="number">5672</span>,<span class="string">&#x27;liyanjun-test&#x27;</span>, credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送到 user.info.test 该routing key 的Exchange 上</span></span><br><span class="line">routing_key = <span class="string">&#x27;user.info.test&#x27;</span></span><br><span class="line">message = <span class="string">&#x27;liyanjun rabbitmq test send...&#x27;</span></span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;userinfo_test&#x27;</span>, routing_key=routing_key, body=message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent %r:%r&quot;</span> % (routing_key, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>Consumer</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;amqp-cn-i7m2fw6ry00u.mq-amqp.cn-hangzhou-249959-a.aliyuncs.com&#x27;</span>, <span class="number">5672</span>,<span class="string">&#x27;liyanjun-test&#x27;</span>, credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># client 1</span></span><br><span class="line">result = channel.queue_declare(<span class="string">&#x27;user_info_queue&#x27;</span>)</span><br><span class="line"><span class="comment"># client 2</span></span><br><span class="line">result = channel.queue_declare(<span class="string">&#x27;user_account_queue&#x27;</span>)    </span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> binding_keys:</span><br><span class="line">    sys.stderr.write(<span class="string">&quot;Usage: %s [binding_key]...\n&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> binding_key <span class="keyword">in</span> binding_keys:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">&#x27;userinfo_test&#x27;</span>, queue=queue_name, routing_key=binding_key)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] %r:%r&quot;</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动client，绑定不同routing key</span></span><br><span class="line">python rabbitmq_client_test1.py user.info.test</span><br><span class="line">python rabbitmq_client_test2.py user.account.test</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证</li>
</ol>
<ul>
<li>userinfo_test Exchange 使用的binding key：<ul>
<li>user.info.#           –&gt;  绑定user_info_queue 此QUEUE 上</li>
<li>user.account.#     –&gt;  绑定user_account_queue 此QUEUE 上</li>
</ul>
</li>
</ul>
<img data-src="/posts/9bae/rbmq10.png" class>

<ul>
<li>Server 端发送携带user.info.test  routing_key 的消息，只有client1 可接收到消息，符合预期。</li>
</ul>
<img data-src="/posts/9bae/rbmq11.png" class>
<img data-src="/posts/9bae/rbmq12.png" class>


<blockquote>
<p>参考：<br>1、官方文档：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a><br>2、消息队列之RabbitMQ：<a href="https://www.jianshu.com/p/79ca08116d57">https://www.jianshu.com/p/79ca08116d57</a><br>3、阿里云云产品官方文档：<a href="https://help.aliyun.com/document_detail/141604.html">https://help.aliyun.com/document_detail&#x2F;141604.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MiddleWare</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Ubuntu + Containerd 部署 K8S 集群</title>
    <url>/posts/28d6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><h4 id="1-multipass-虚拟机创建"><a href="#1-multipass-虚拟机创建" class="headerlink" title="1. multipass  虚拟机创建"></a>1. multipass  虚拟机创建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成密钥对</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -f ~/k8s_rsa -C k8s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 Master 节点</span></span><br><span class="line">multipass launch -c 2 -m 2G -d 20G -n master --cloud-init - &lt;&lt; EOF</span><br><span class="line">ssh_authorized_keys:</span><br><span class="line">- $(cat ~/.ssh/k8s_rsa.pub)</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 Node 节点</span></span><br><span class="line">multipass launch -c 1 -m 2G -d 20G -n node1 --cloud-init - &lt;&lt; EOF</span><br><span class="line">ssh_authorized_keys:</span><br><span class="line">- $(cat ~/.ssh/k8s_rsa.pub)</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">multipass launch -c 1 -m 2G -d 20G -n node2 --cloud-init - &lt;&lt; EOF</span><br><span class="line">ssh_authorized_keys:</span><br><span class="line">- $(cat ~/.ssh/k8s_rsa.pub)</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–cloud-init ：导入本地生成的公钥文件到初始化系统中，可以使用密钥免密 SSH</p>
</blockquote>
<span id="more"></span>


<h4 id="2-主机与网络规划"><a href="#2-主机与网络规划" class="headerlink" title="2. 主机与网络规划"></a>2. 主机与网络规划</h4><table>
<thead>
<tr>
<th><strong>主机 IP</strong></th>
<th><strong>主机名</strong></th>
<th><strong>主机配置</strong></th>
<th><strong>节点角色</strong></th>
</tr>
</thead>
<tbody><tr>
<td>192.168.64.4</td>
<td>master1</td>
<td>2C&#x2F;2G</td>
<td>master 节点</td>
</tr>
<tr>
<td>192.168.64.5</td>
<td>node1</td>
<td>1C&#x2F;1G</td>
<td>node 节点</td>
</tr>
<tr>
<td>192.168.64.6</td>
<td>node2</td>
<td>1C&#x2F;1G</td>
<td>node 节点</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>子网 Subnet</strong></th>
<th><strong>CIDR 网段</strong></th>
</tr>
</thead>
<tbody><tr>
<td>nodeSubnet</td>
<td>192.168.64.0&#x2F;24</td>
</tr>
<tr>
<td>PodSubnet</td>
<td>172.16.0.0&#x2F;16</td>
</tr>
<tr>
<td>ServiceSubnet</td>
<td>10.10.0.0&#x2F;16</td>
</tr>
</tbody></table>
<h4 id="3-软件版本"><a href="#3-软件版本" class="headerlink" title="3.软件版本"></a>3.软件版本</h4><table>
<thead>
<tr>
<th><strong>软件</strong></th>
<th><strong>版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>Ubuntu 20.04.4 LTS</td>
</tr>
<tr>
<td>内核版本</td>
<td>5.4.0-109-generic</td>
</tr>
<tr>
<td>containerd</td>
<td>1.5.10-1</td>
</tr>
<tr>
<td>kubernetes</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>kubeadm</li>
<li>kube-apiserver</li>
<li>kube-controller-manager</li>
<li>kubectl</li>
<li>kubelet</li>
<li>kube-proxy</li>
<li>kube-scheduler<br> | v1.23.2 |<br>| etcd | v3.5.1 |<br>| CNI 插件（calico） | v3.18 |</li>
</ul>
<h3 id="二、集群配置（所有节点执行）"><a href="#二、集群配置（所有节点执行）" class="headerlink" title="二、集群配置（所有节点执行）"></a>二、集群配置（所有节点执行）</h3><h4 id="1-节点初始化"><a href="#1-节点初始化" class="headerlink" title="1. 节点初始化"></a>1. 节点初始化</h4><ul>
<li><p>主机名与 host 解析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl --static set-hostname master    # master 节点执行</span><br><span class="line">hostnamectl --static set-hostname node1     # node1 节点执行</span><br><span class="line">hostnamectl --static set-hostname node2     # node2 节点执行</span><br><span class="line"></span><br><span class="line">sudo tee -a /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.64.4 master</span><br><span class="line">192.168.64.5 node1</span><br><span class="line">192.168.64.6 node2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙与禁用 swap 分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable &amp;&amp; sudo systemctl disable ufw</span><br><span class="line"></span><br><span class="line">swapoff -a</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>
<blockquote>
<p>*** k8s集群安装为什么需要关闭 swap 分区？ swap 必须关，否则 kubelet 起不来,进而导致 k8s 集群起不来； 且考虑 kublet 会用 swap 做数据交换的话，对性能影响比较大</p>
</blockquote>
</li>
<li><p>同步时间与时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">sudo timedatectl set-timezone Asia/Shanghai</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前的 UTC 时间写入硬件时钟 (硬件时间默认为UTC)</span></span><br><span class="line">sudo timedatectl set-local-rtc 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 NTP 时间同步：</span></span><br><span class="line">sudo timedatectl set-ntp yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校准时间服务器-时间同步(推荐使用 chronyc 进行平滑同步)</span></span><br><span class="line">sudo apt-get install chrony -y</span><br><span class="line">sudo chronyc tracking</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动校准-强制更新时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chronyc -a makestep</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统时钟同步硬件时钟</span></span><br><span class="line">sudo hwclock -w</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启依赖于系统时间的服务</span></span><br><span class="line">sudo systemctl restart rsyslog.service cron.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>内核模块加载与配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装 ipvs</span></span><br><span class="line">sudo apt-get install ipset ipvsadm -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.加载内核模块</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置重启后永久加载模块</span></span><br><span class="line">sudo tee /etc/modules-load.d/k8s.conf &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netfilter</span></span><br><span class="line">br_netfilter</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">containerd.</span></span><br><span class="line">overlay</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipvs</span></span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时加载模块</span></span><br><span class="line">mod_tmp=(br_netfilter overlay ip_vs ip_vs_rr ip_vs_wrr ip_vs_sh nf_conntrack)</span><br><span class="line">for m in $&#123;mod_tmp[@]&#125;;do sudo modprobe $m; done</span><br><span class="line">lsmod | egrep &quot;ip_vs|nf_conntrack_ipv4&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.配置内核参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 sysctl 必须参数，重启后永久生效</span></span><br><span class="line">sudo tee /etc/sysctl.d/99-kubernetes-cri.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ipv6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时应用 sysctl 参数而无需重新启动</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置免密登录（master 节点执行，非必须）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master 节点执行</span></span><br><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@node1</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@node2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-容器运行时安装"><a href="#2-容器运行时安装" class="headerlink" title="2. 容器运行时安装"></a>2. 容器运行时安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.删除旧版本</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.更新 apt 程序包索引并安装程序包，以允许 apt 通过 HTTPS 使用存储库</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">  apt-transport-https \</span><br><span class="line">  ca-certificates \</span><br><span class="line">  curl \</span><br><span class="line">  gnupg \</span><br><span class="line">  lsb-release -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.添加 Docker 的官方 GPG 密钥</span></span><br><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.设置稳定存储库，添加 nightly 或 <span class="built_in">test</span> 存储库</span></span><br><span class="line">echo &quot;deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line"><span class="meta prompt_"> $</span><span class="language-bash">(lsb_release -cs) stable nightly<span class="string">&quot; | sudo tee /etc/apt/sources.list.d/container.list</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">5.安装 containerd</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">更新 apt 包索引，安装最新版本的 containerd 或进入下一步安装特定版本</span></span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">查看 containerd.io 可用的版本</span></span></span><br><span class="line">apt-cache madison containerd.io</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">安装指定版本</span></span></span><br><span class="line">sudo apt install containerd.io=1.5.10-1 -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">6.配置 containerd</span></span></span><br><span class="line">containerd config default | sudo tee /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">替换 pause 镜像源</span></span></span><br><span class="line">sudo sed -i &quot;s#k8s.gcr.io/pause#registry.cn-hangzhou.aliyuncs.com/google_containers/pause#g&quot;  /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">docker.io &amp; gcr.io &amp; k8s.gcr.io &amp; quay.io 镜像加速</span></span></span><br><span class="line">sudo tee ~/tmp.txt &lt;&lt; EOF</span><br><span class="line">        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span><br><span class="line">          endpoint = [&quot;https://taa4w07u.mirror.aliyuncs.com&quot;]</span><br><span class="line">        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;gcr.io&quot;]</span><br><span class="line">          endpoint = [&quot;https://gcr.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;]</span><br><span class="line">          endpoint = [&quot;https://gcr.mirrors.ustc.edu.cn/google-containers/&quot;, &quot;https://registry.aliyuncs.com/google-containers/&quot;]</span><br><span class="line">        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;quay.io&quot;]</span><br><span class="line">          endpoint = [&quot;https://quay.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">EOF</span><br><span class="line">sudo sed -i &#x27;/registry.mirrors\]/r ./tmp.txt&#x27; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">使用 SystemdCgroup 驱动程序，节点资源紧张时更稳定</span></span></span><br><span class="line">sudo sed -i &#x27;s# SystemdCgroup = false# SystemdCgroup = true#g&#x27; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">7.启动 containerd 并验证</span></span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable containerd</span><br><span class="line">sudo systemctl restart containerd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">验证</span></span></span><br><span class="line">sudo ctr version</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、构建集群"><a href="#三、构建集群" class="headerlink" title="三、构建集群"></a>三、构建集群</h3><h4 id="1-组件安装（所有节点执行）"><a href="#1-组件安装（所有节点执行）" class="headerlink" title="1.组件安装（所有节点执行）"></a>1.组件安装（所有节点执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用阿里云加速镜像</span></span><br><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -</span><br><span class="line">sudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt; EOF</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新 apt 包索引 &amp; 查看并安装版本</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">apt-cache madison kubeadm |head</span><br><span class="line">sudo apt install kubeadm=1.23.2-00 kubelet=1.23.2-00 kubectl=1.23.2-00 -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">锁定版本</span></span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置客户端工具 runtime 与镜像端点配置</span></span><br><span class="line">sudo crictl config runtime-endpoint /run/containerd/containerd.sock</span><br><span class="line">sudo tee /etc/crictl.yaml &lt;&lt; EOF</span><br><span class="line">runtime-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">timeout: 10</span><br><span class="line">debug: false</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载 systemd 守护进程并将 kubelet 设置开机启动</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable --now kubelet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 kubelet 状态异常，会每隔几秒重启，陷入等待 kubeadm 指令的死循环</span></span><br><span class="line">systemctl status kubelet </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-初始化主节点"><a href="#2-初始化主节点" class="headerlink" title="2.初始化主节点"></a>2.初始化主节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出默认初始化配置</span></span><br><span class="line">kubeadm config print init-defaults &gt; kubeadm.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据本地环境修改初始配置内容</span></span><br><span class="line">cat &gt; kubeadm.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.64.4 # 修改 master 节点 IP</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /run/containerd/containerd.sock # 修改容器运行时为 containerd</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: master # 修改 master 节点名称</span><br><span class="line">  taints: # master 节点添加污点，不能调度应用</span><br><span class="line">  - effect: &quot;NoSchedule&quot;</span><br><span class="line">    key: &quot;node-role.kubernetes.io/master&quot;</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers # 修改镜像加速地址</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.23.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  podSubnet: 172.16.0.0/16  # 修改 Pod 子网</span><br><span class="line">  serviceSubnet: 10.10.0.0/16 # 修改 Service CIDR 网段</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs # 修改kube-proxy 模式为ipvs，默认为iptables</span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: systemd # 配置 cgroup driver</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看初始化集群所需镜像与提前拉取</span></span><br><span class="line">kubeadm config images list --config kubeadm.yaml</span><br><span class="line">kubeadm config images pull --config kubeadm.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化 master 节点</span></span><br><span class="line">sudo kubeadm init --config=kubeadm.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">初始化完成生成的命令：Node 节点执行，加入集群</span></span><br><span class="line">sudo kubeadm join 192.168.64.4:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:6e25620c2478e38edfe335761b8dd37dbbe0dc8c1df9b41d539b148732d32718</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印 <span class="built_in">join</span> token 值</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kubeadm token create --print-join-command</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">初始化完成生成的命令：用于 kubectl 命令</span></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<h4 id="3-安装-CNI-网络插件（calico）"><a href="#3-安装-CNI-网络插件（calico）" class="headerlink" title="3.安装 CNI 网络插件（calico）"></a>3.安装 CNI 网络插件（calico）</h4><blockquote>
<p>calico 插件官方地址：<a href="https://projectcalico.docs.tigera.io/getting-started/kubernetes/quickstart">https://projectcalico.docs.tigera.io/getting-started/kubernetes/quickstart</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">calico 官方下载 calico 插件部署清单</span></span><br><span class="line">wget https://docs.projectcalico.org/v3.18/manifests/calico.yaml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">wget https://docs.projectcalico.org/v3.22/manifests/calico.yaml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改自定义配置</span></span><br><span class="line">vim calico.yaml</span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line">  value: &quot;172.16.0.0/16&quot;</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证等待 calico 插件 Pod 成功运行</span></span><br><span class="line">watch kubectl get pod -n kube-system</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS     AGE</span><br><span class="line">calico-kube-controllers-6cfb54c7bb-7xdld   1/1     Running   0            2m51s</span><br><span class="line">calico-node-sjr6r                          1/1     Running   0            2m52s</span><br><span class="line">calico-node-vsczr                          1/1     Running   0            2m51s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置节点角色</span></span><br><span class="line">kubectl label nodes master node-role.kubernetes.io/control-plane=</span><br><span class="line">kubectl label nodes node1 node-role.kubernetes.io/work=</span><br><span class="line">kubectl label nodes node2 node-role.kubernetes.io/work=</span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自动补齐 kubectl 命令</span></span><br><span class="line">sudo apt install -y bash-completion</span><br><span class="line">source /usr/share/bash-completion/bash_completion</span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nerdctl 工具（替代 docker 命令）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">官方地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://github.com/containerd/nerdctl</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载安装</span></span><br><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.20.0/nerdctl-0.20.0-linux-amd64.tar.gz</span><br><span class="line">tar Cxfz /usr/local/bin/ nerdctl-0.20.0-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用方式</span></span><br><span class="line">sudo nerdctl -n k8s.io images </span><br><span class="line">sudo nerdctl -n k8s.io ps</span><br><span class="line">sudo nerdctl -n k8s.io images     # 等同于 = sudo ctr -n k8s.io images ls</span><br><span class="line">sudo nerdctl -n k8s.io pull nginx # 等同于 = sudo crictl pull nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">flannel 插件重置方式，非适用 calico</span></span><br><span class="line">kubeadm reset</span><br><span class="line">ifconfig cni0 down &amp;&amp; ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down &amp;&amp; ip link delete flannel.1</span><br><span class="line">rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure>

<h4 id="4-集群部署验证"><a href="#4-集群部署验证" class="headerlink" title="4.集群部署验证"></a>4.集群部署验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署 Nginx Deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暴露 Nginx 服务，类型为 NodePort</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --target-port=80 --type=NodePort </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问验证</span></span><br><span class="line">curl 10.10.225.108:80 -I      # 请求 Service 端口（port，集群内部）</span><br><span class="line">curl 192.168.64.5:31052 -I    # 请求 Node 节点端口（nodePort，可集群外部访问）</span><br><span class="line">curl 172.16.166.132:80 -I     # 请求 Pod 应用内部端口（targetPort，容器的启动端口）</span><br></pre></td></tr></table></figure>

<h4 id="5-Kubernetes-组件"><a href="#5-Kubernetes-组件" class="headerlink" title="5.Kubernetes 组件"></a>5.Kubernetes 组件</h4><p><strong>控制平台组件</strong></p>
<ul>
<li>kube-apiserver：多实例伸缩，高可用且可均衡流量？</li>
<li>etcd：高可用与备份策略？</li>
<li>kube-scheduler  调度策略：Pod 资源需求、硬件&#x2F;软件&#x2F;策略约束、亲和性和反亲和性规范、数据位置、工作负载间干扰和最后时限</li>
<li>kube-controller-manager</li>
</ul>
<p><strong>Node 组件（所有节点）</strong></p>
<ul>
<li>kubelet</li>
<li>kubeproxy</li>
<li>容器运行时（CR）：containerd（K8S 后续版本不使用 docker）</li>
</ul>
<p><strong>插件 Addons</strong></p>
<ul>
<li>网络插件：calico、flannel</li>
</ul>
<p><strong>可观测性：日志与监控</strong></p>
<ul>
<li>日志：fluentd</li>
<li>监控：Prometheus</li>
</ul>
<h3 id="四、Kubernetes-仪表板（Dashboard）"><a href="#四、Kubernetes-仪表板（Dashboard）" class="headerlink" title="四、Kubernetes 仪表板（Dashboard）"></a>四、Kubernetes 仪表板（Dashboard）</h3><h4 id="1-K8S-原生仪表板"><a href="#1-K8S-原生仪表板" class="headerlink" title="1.K8S 原生仪表板"></a>1.K8S 原生仪表板</h4><blockquote>
<p>官方文档：<a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.部署 Dashboard 清单</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.1/aio/deploy/recommended.yaml</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kubectl apply -f recommended.yaml</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.0/aio/deploy/recommended.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.启用 Dashboard 访问</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看资源是否正常启动</span></span><br><span class="line">kubectl get pod,service -n kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改服务暴露为 nodePort 方式</span></span><br><span class="line">kubectl edit service kubernetes-dashboard -n kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">===主要配置内容</span></span><br><span class="line">  ports:</span><br><span class="line">  - nodePort: 30333  # 新增</span><br><span class="line">    port: 443</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  type: NodePort  # 修改</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###</span></span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.默认仪表板部署为最小 RBAC 权限集，需要操作资源时，需要创建 ClusterRole 角色。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RBAC 参考：https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/README.md</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登录 Dashboard</span></span><br><span class="line">kubectl describe secret -n kubernetes-dashboard $(kubectl get secret -n kubernetes-dashboard |grep kubernetes-dashboard-token |awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">浏览器访问（使用firefox） https://192.168.64.4:30333</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用上面获取的 token 值登录（默认 token 只有 kubernetes-dashboard 空间权限）</span></span><br></pre></td></tr></table></figure>

<h4 id="2-K9S-集群管理工具"><a href="#2-K9S-集群管理工具" class="headerlink" title="2.K9S 集群管理工具"></a>2.K9S 集群管理工具</h4><p>官方文档：<a href="https://k9scli.io/">https://k9scli.io/</a></p>
<h3 id="五、参考文档"><a href="#五、参考文档" class="headerlink" title="五、参考文档"></a>五、参考文档</h3><p>1、<a href="https://multipass.run/">multipass 官网</a><br>2、<a href="https://kubernetes.io/zh/docs/concepts/overview/components/#container-runtime">Kubernetes 官方文档</a><br>3、<a href="https://blog.weiyigeek.top/2022/5-7-654.html">二进制方式安装 K8S 集群</a></p>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
</search>
